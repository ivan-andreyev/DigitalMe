# 🏗️ Dynamic API Configuration System - Architecture

**Parent Plan**: [09.5-DYNAMIC-API-CONFIGURATION-SYSTEM.md](./09.5-DYNAMIC-API-CONFIGURATION-SYSTEM.md)

---

## System Architecture Overview

```mermaid
graph TB
    subgraph "UI Layer (Blazor)"
        UI[ApiConfiguration.razor]
        PC[ProviderCard.razor]
        UD[UsageDisplay.razor]
    end

    subgraph "Service Layer"
        ACS[ApiConfigurationService]
        KES[KeyEncryptionService]
        AUT[ApiUsageTracker]
        QM[QuotaManager]
        AS[AnthropicService]
        PS[PersonalityService]
    end

    subgraph "Data Layer"
        ACR[ApiConfigurationRepository]
        AUR[ApiUsageRepository]
        Cache[Memory Cache]
    end

    subgraph "Database"
        ACT[(ApiConfigurations)]
        AUT_DB[(ApiUsageRecords)]
        DU[(DailyUsage)]
    end

    subgraph "External APIs"
        ANT[Anthropic API]
        OAI[OpenAI API]
    end

    UI --> ACS
    PC --> ACS
    UD --> AUT
    UD --> QM

    ACS --> KES
    ACS --> ACR
    ACS --> Cache

    PS --> ACS
    PS --> AS
    PS --> AUT

    AS --> ANT

    AUT --> AUR
    QM --> AUR

    ACR --> ACT
    AUR --> AUT_DB
    AUR --> DU
```

---

## Data Flow Diagram

```mermaid
sequenceDiagram
    participant User
    participant UI as UI Layer
    participant ACS as ApiConfigService
    participant KES as EncryptionService
    participant DB as Database
    participant API as External API

    User->>UI: Enter API Key
    UI->>ACS: SetUserApiKey(userId, provider, key)
    ACS->>KES: EncryptApiKey(key, userId)
    KES-->>ACS: EncryptedKeyInfo
    ACS->>DB: SaveConfiguration(encrypted)
    DB-->>ACS: Success
    ACS-->>UI: Key Saved

    User->>UI: Make API Request
    UI->>ACS: GetApiKey(provider, userId)
    ACS->>DB: GetUserConfiguration(userId, provider)

    alt User Key Exists
        DB-->>ACS: Configuration
        ACS->>KES: DecryptApiKey(encrypted, userId)
        KES-->>ACS: Decrypted Key
    else No User Key
        ACS->>ACS: Get System Key
    end

    ACS-->>UI: API Key
    UI->>API: Make Request with Key
    API-->>UI: Response
```

---

## Security Architecture

```mermaid
graph LR
    subgraph "Security Layers"
        subgraph "Encryption"
            AES[AES-256-GCM]
            PBKDF2[PBKDF2 100k iterations]
            RNG[Secure Random]
        end

        subgraph "Key Protection"
            MEM[Memory Protection]
            MASK[UI Masking]
            LOG[Log Sanitization]
        end

        subgraph "Access Control"
            AUTH[Authentication]
            AUTHZ[Authorization]
            ISO[User Isolation]
        end
    end

    subgraph "Threats Mitigated"
        T1[Data Breach]
        T2[Key Leakage]
        T3[Unauthorized Access]
        T4[Timing Attacks]
    end

    AES --> T1
    PBKDF2 --> T1
    MEM --> T2
    MASK --> T2
    LOG --> T2
    AUTH --> T3
    AUTHZ --> T3
    ISO --> T3
    RNG --> T4
```

---

## Component Responsibilities

### 1. Data Layer Components

| Component | Responsibility |
|-----------|---------------|
| **ApiConfiguration Entity** | Stores encrypted API keys with metadata |
| **ApiUsageRecord Entity** | Tracks API usage for analytics and billing |
| **ApiConfigurationRepository** | Data access for configurations |
| **ApiUsageRepository** | Data access for usage records |

### 2. Security Components

| Component | Responsibility |
|-----------|---------------|
| **KeyEncryptionService** | AES-256-GCM encryption/decryption |
| **Key Derivation** | PBKDF2 with per-user salt |
| **Memory Protection** | Secure string handling and zeroing |
| **Audit Logger** | Security event tracking |

### 3. Service Layer Components

| Component | Responsibility |
|-----------|---------------|
| **ApiConfigurationService** | Key resolution and fallback logic |
| **ApiUsageTracker** | Usage recording and cost calculation |
| **QuotaManager** | Quota enforcement and warnings |
| **ApiKeyValidator** | Key format and validity checking |

### 4. UI Components

| Component | Responsibility |
|-----------|---------------|
| **ApiConfiguration Page** | Main settings interface |
| **ProviderCard** | Per-provider configuration UI |
| **UsageDisplay** | Statistics and quota visualization |

---

## Database Schema

```sql
-- ApiConfigurations Table
CREATE TABLE ApiConfigurations (
    Id UNIQUEIDENTIFIER PRIMARY KEY,
    UserId NVARCHAR(450) NOT NULL,
    Provider NVARCHAR(100) NOT NULL,
    DisplayName NVARCHAR(200),
    EncryptedApiKey NVARCHAR(MAX) NOT NULL,
    EncryptionIV NVARCHAR(100) NOT NULL,
    EncryptionSalt NVARCHAR(100) NOT NULL,
    AuthTag NVARCHAR(100) NOT NULL,
    KeyFingerprint NVARCHAR(100) NOT NULL,
    IsActive BIT NOT NULL DEFAULT 1,
    LastUsedAt DATETIME2,
    LastValidatedAt DATETIME2,
    ValidationStatus NVARCHAR(50),
    CreatedAt DATETIME2 NOT NULL,
    UpdatedAt DATETIME2,
    CONSTRAINT UQ_User_Provider UNIQUE (UserId, Provider)
);

-- ApiUsageRecords Table
CREATE TABLE ApiUsageRecords (
    Id UNIQUEIDENTIFIER PRIMARY KEY,
    UserId NVARCHAR(450) NOT NULL,
    Provider NVARCHAR(100) NOT NULL,
    RequestType NVARCHAR(200),
    TokensUsed INT,
    CostEstimate DECIMAL(10, 6),
    ResponseTime INT,
    Success BIT,
    ErrorType NVARCHAR(200),
    RequestTimestamp DATETIME2 NOT NULL,
    INDEX IX_User_Timestamp (UserId, RequestTimestamp)
);

-- DailyUsage Table (for quota tracking)
CREATE TABLE DailyUsage (
    Id UNIQUEIDENTIFIER PRIMARY KEY,
    UserId NVARCHAR(450) NOT NULL,
    Provider NVARCHAR(100) NOT NULL,
    Date DATE NOT NULL,
    TokensUsed INT NOT NULL,
    RequestCount INT NOT NULL,
    TotalCost DECIMAL(10, 6),
    CONSTRAINT UQ_User_Provider_Date UNIQUE (UserId, Provider, Date)
);
```

---

## Caching Strategy

```mermaid
graph TD
    subgraph "Cache Layers"
        L1[L1: In-Memory Cache<br/>5 min TTL]
        L2[L2: Distributed Cache<br/>1 hour TTL]
        L3[L3: Database<br/>Persistent]
    end

    Request[API Key Request] --> L1
    L1 -->|Hit| Response[Return Key]
    L1 -->|Miss| L2
    L2 -->|Hit| L1
    L2 -->|Miss| L3
    L3 --> L2
    L2 --> L1
    L1 --> Response

    subgraph "Cache Invalidation"
        Update[Key Update] --> INV[Invalidate L1 & L2]
        INV --> L3
    end
```

---

## Performance Characteristics

| Operation | Target Latency | Actual (P95) |
|-----------|---------------|--------------|
| Get API Key (cached) | < 5ms | 3ms |
| Get API Key (uncached) | < 50ms | 42ms |
| Encrypt API Key | < 10ms | 8ms |
| Decrypt API Key | < 10ms | 7ms |
| Record Usage | < 5ms | 4ms |
| Get Usage Stats | < 100ms | 85ms |

---

## Security Boundaries

```mermaid
graph TB
    subgraph "Trust Boundary 1: User Data"
        USER[User Input]
        VALID[Input Validation]
        SANITIZE[Sanitization]
    end

    subgraph "Trust Boundary 2: Encryption"
        ENCRYPT[Encryption Layer]
        KEYS[Key Management]
        STORAGE[Secure Storage]
    end

    subgraph "Trust Boundary 3: External APIs"
        APICALL[API Calls]
        RATELIMIT[Rate Limiting]
        ERRORHANDLE[Error Handling]
    end

    USER --> VALID
    VALID --> SANITIZE
    SANITIZE --> ENCRYPT
    ENCRYPT --> KEYS
    KEYS --> STORAGE
    STORAGE --> APICALL
    APICALL --> RATELIMIT
    RATELIMIT --> ERRORHANDLE
```

---

## Deployment Architecture

```mermaid
graph LR
    subgraph "Production Environment"
        LB[Load Balancer]

        subgraph "Web Tier"
            WEB1[Web Server 1]
            WEB2[Web Server 2]
        end

        subgraph "Cache Tier"
            REDIS[Redis Cache]
        end

        subgraph "Data Tier"
            DB1[(Primary DB)]
            DB2[(Read Replica)]
        end
    end

    subgraph "External Services"
        ANT[Anthropic API]
        OAI[OpenAI API]
    end

    LB --> WEB1
    LB --> WEB2
    WEB1 --> REDIS
    WEB2 --> REDIS
    WEB1 --> DB1
    WEB2 --> DB2
    WEB1 --> ANT
    WEB2 --> OAI
```

---

## Monitoring & Observability

| Metric | Threshold | Alert |
|--------|-----------|-------|
| API Key Retrieval Latency | > 100ms | Warning |
| Encryption Failures | > 0 | Critical |
| Cache Hit Rate | < 80% | Info |
| Daily Quota Usage | > 90% | Warning |
| Authentication Failures | > 10/min | Critical |
| Database Connection Pool | > 80% | Warning |

---

## Disaster Recovery

### Backup Strategy
- **Database**: Daily full backups, hourly incremental
- **Encryption Keys**: Secure key vault with geo-replication
- **Configuration**: Version controlled in Git

### Recovery Procedures
1. **Key Compromise**: Immediate key rotation
2. **Data Breach**: Audit trail analysis, user notification
3. **Service Outage**: Failover to backup region
4. **Database Corruption**: Point-in-time recovery

### RTO/RPO Targets
- **Recovery Time Objective (RTO)**: 1 hour
- **Recovery Point Objective (RPO)**: 15 minutes