# P3.1.5 Production Integration Testing

**Parent Plan**: [P3.1-Production-Readiness-Foundation-Plan.md](../P3.1-Production-Readiness-Foundation-Plan.md)  
**Timeline**: Week 5 (25 hours) | **Priority**: CRITICAL | **Dependencies**: All P3.1.1-P3.1.4 components

## üéØ COMPONENT MISSION

Execute comprehensive production integration testing including end-to-end security validation, load testing with 500+ concurrent users, database integrity testing, and complete production deployment validation to ensure DigitalMe meets all production readiness criteria.

**Success Criteria**: 99.5%+ uptime validation, 500+ concurrent user support, zero critical failures, production deployment success

---

## üìä CURRENT STATE ANALYSIS

### Prerequisites from P3.1.1-P3.1.4
‚úÖ **P3.1.1 JWT Authentication**: User management and secure authentication ready  
‚úÖ **P3.1.2 API Security Hardening**: Rate limiting, input validation, API key management  
‚úÖ **P3.1.3 Production Monitoring**: Health checks, metrics, alerting system  
‚úÖ **P3.1.4 Deployment Pipeline**: CI/CD, containerization, blue-green deployment  
‚ùå **Integration Testing Suite** - Comprehensive testing framework needed  
‚ùå **Load Testing Infrastructure** - Performance validation under load  
‚ùå **Security Testing Automation** - Automated security vulnerability assessment  
‚ùå **Production Readiness Validation** - End-to-end production scenario testing  

### Integration Validation Requirements
- **Complete System Integration**: All P3.1 components working together seamlessly
- **P2.1-P2.4 Compatibility**: Existing personality engine functionality preserved
- **Performance Under Load**: 500+ concurrent users with <2s response times
- **Security Validation**: Zero critical vulnerabilities, comprehensive threat testing
- **Deployment Validation**: Blue-green deployment with zero-downtime verification

---

## üîß IMPLEMENTATION TASKS

### Task 1: End-to-End Integration Test Suite (8 hours)

#### 1.1 Integration Testing Framework
**File**: `tests/Integration/IntegrationTestFixture.cs`
```csharp
public class IntegrationTestFixture : IAsyncLifetime
{
    public WebApplicationFactory<Program> Factory { get; private set; } = null!;
    public HttpClient Client { get; private set; } = null!;
    public IServiceScope Scope { get; private set; } = null!;
    
    private readonly PostgreSqlContainer _dbContainer;
    private readonly RedisContainer _redisContainer;
    private readonly WireMockServer _mockClaudeApi;

    public IntegrationTestFixture()
    {
        // Initialize test containers
        _dbContainer = new PostgreSqlBuilder()
            .WithImage("postgres:15-alpine")
            .WithDatabase("DigitalMeTest")
            .WithUsername("test")
            .WithPassword("test123")
            .WithCleanUp(true)
            .Build();

        _redisContainer = new RedisBuilder()
            .WithImage("redis:7-alpine")
            .WithCleanUp(true)
            .Build();

        // Mock external dependencies
        _mockClaudeApi = WireMockServer.Start();
        SetupClaudeApiMocks();
    }

    public async Task InitializeAsync()
    {
        // Start test containers
        await _dbContainer.StartAsync();
        await _redisContainer.StartAsync();

        // Configure test application
        Factory = new WebApplicationFactory<Program>()
            .WithWebHostBuilder(builder =>
            {
                builder.ConfigureTestServices(services =>
                {
                    // Replace database connection
                    services.RemoveAll(typeof(DbContextOptions<ApplicationDbContext>));
                    services.AddDbContext<ApplicationDbContext>(options =>
                        options.UseNpgsql(_dbContainer.GetConnectionString()));

                    // Replace Redis connection
                    services.RemoveAll(typeof(IConnectionMultiplexer));
                    services.AddSingleton<IConnectionMultiplexer>(provider =>
                        ConnectionMultiplexer.Connect(_redisContainer.GetConnectionString()));

                    // Replace Claude API with mock
                    services.RemoveAll(typeof(IClaudeApiService));
                    services.AddScoped<IClaudeApiService, MockClaudeApiService>();

                    // Override configuration
                    services.Configure<JwtSettings>(options =>
                    {
                        options.SecretKey = "TestSecretKeyThatIsLongEnoughFor256Bits!";
                        options.Issuer = "DigitalMeTest";
                        options.Audience = "DigitalMeTest";
                        options.TokenExpiryMinutes = 60;
                    });
                });

                builder.UseEnvironment("Testing");
            });

        Client = Factory.CreateClient();
        Scope = Factory.Services.CreateScope();

        // Apply migrations
        var dbContext = Scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        await dbContext.Database.MigrateAsync();

        // Seed test data
        await SeedTestDataAsync();
    }

    public async Task DisposeAsync()
    {
        Scope?.Dispose();
        Client?.Dispose();
        Factory?.Dispose();
        _mockClaudeApi?.Stop();
        await _dbContainer.StopAsync();
        await _redisContainer.StopAsync();
    }

    private void SetupClaudeApiMocks()
    {
        // Mock successful personality generation
        _mockClaudeApi
            .Given(Request.Create().WithPath("/v1/messages").UsingPost())
            .RespondWith(Response.Create()
                .WithStatusCode(200)
                .WithHeader("Content-Type", "application/json")
                .WithBody(JsonSerializer.Serialize(new
                {
                    id = "msg_test123",
                    content = new[]
                    {
                        new { type = "text", text = "This is a test personality response generated for integration testing." }
                    }
                })));

        // Mock health check
        _mockClaudeApi
            .Given(Request.Create().WithPath("/v1/health").UsingGet())
            .RespondWith(Response.Create()
                .WithStatusCode(200)
                .WithBody("OK"));
    }

    private async Task SeedTestDataAsync()
    {
        var dbContext = Scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        var passwordService = Scope.ServiceProvider.GetRequiredService<IPasswordService>();

        // Create test users
        var testUsers = new[]
        {
            new User
            {
                Email = "admin@test.com",
                FirstName = "Test",
                LastName = "Admin",
                PasswordHash = passwordService.HashPassword("TestAdmin123!"),
                Role = UserRole.Admin,
                IsActive = true,
                IsEmailConfirmed = true
            },
            new User
            {
                Email = "user@test.com",
                FirstName = "Test",
                LastName = "User",
                PasswordHash = passwordService.HashPassword("TestUser123!"),
                Role = UserRole.User,
                IsActive = true,
                IsEmailConfirmed = true
            }
        };

        dbContext.Users.AddRange(testUsers);
        await dbContext.SaveChangesAsync();

        // Create test personality profiles
        var testProfile = new PersonalityProfile
        {
            Name = "Test Profile",
            OwnerId = testUsers[1].Id,
            PersonalityData = JsonDocument.Parse(@"{
                ""traits"": {
                    ""openness"": 0.8,
                    ""conscientiousness"": 0.7,
                    ""extraversion"": 0.6,
                    ""agreeableness"": 0.9,
                    ""neuroticism"": 0.3
                },
                ""preferences"": {
                    ""communication_style"": ""direct"",
                    ""response_length"": ""medium""
                }
            }")
        };

        dbContext.PersonalityProfiles.Add(testProfile);
        await dbContext.SaveChangesAsync();
    }

    public async Task<string> GetAuthTokenAsync(string email = "user@test.com", string password = "TestUser123!")
    {
        var loginRequest = new { Email = email, Password = password };
        var loginResponse = await Client.PostAsJsonAsync("/api/auth/login", loginRequest);
        
        loginResponse.EnsureSuccessStatusCode();
        var loginResult = await loginResponse.Content.ReadFromJsonAsync<AuthResponse>();
        
        return loginResult!.AccessToken;
    }

    public async Task<string> GetAdminTokenAsync()
    {
        return await GetAuthTokenAsync("admin@test.com", "TestAdmin123!");
    }
}

[CollectionDefinition("Integration Tests")]
public class IntegrationTestCollection : ICollectionFixture<IntegrationTestFixture>
{
}
```

#### 1.2 Authentication Integration Tests
**File**: `tests/Integration/AuthenticationIntegrationTests.cs`
```csharp
[Collection("Integration Tests")]
public class AuthenticationIntegrationTests
{
    private readonly IntegrationTestFixture _fixture;
    private readonly HttpClient _client;

    public AuthenticationIntegrationTests(IntegrationTestFixture fixture)
    {
        _fixture = fixture;
        _client = fixture.Client;
    }

    [Fact]
    public async Task CompleteAuthenticationFlow_ShouldWorkEndToEnd()
    {
        // Test registration
        var registerRequest = new
        {
            Email = "newuser@test.com",
            FirstName = "New",
            LastName = "User",
            Password = "NewUser123!"
        };

        var registerResponse = await _client.PostAsJsonAsync("/api/auth/register", registerRequest);
        Assert.Equal(HttpStatusCode.OK, registerResponse.StatusCode);

        // Test login with new user (would normally require email confirmation)
        // For testing, we'll enable the user directly
        using var scope = _fixture.Scope;
        var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        var newUser = await dbContext.Users.FirstAsync(u => u.Email == "newuser@test.com");
        newUser.IsEmailConfirmed = true;
        await dbContext.SaveChangesAsync();

        // Test login
        var loginRequest = new
        {
            Email = "newuser@test.com",
            Password = "NewUser123!"
        };

        var loginResponse = await _client.PostAsJsonAsync("/api/auth/login", loginRequest);
        Assert.Equal(HttpStatusCode.OK, loginResponse.StatusCode);

        var loginResult = await loginResponse.Content.ReadFromJsonAsync<AuthResponse>();
        Assert.NotNull(loginResult);
        Assert.NotEmpty(loginResult.AccessToken);
        Assert.NotEmpty(loginResult.RefreshToken);

        // Test token refresh
        var refreshRequest = new
        {
            AccessToken = loginResult.AccessToken,
            RefreshToken = loginResult.RefreshToken
        };

        var refreshResponse = await _client.PostAsJsonAsync("/api/auth/refresh", refreshRequest);
        Assert.Equal(HttpStatusCode.OK, refreshResponse.StatusCode);

        var refreshResult = await refreshResponse.Content.ReadFromJsonAsync<AuthResponse>();
        Assert.NotNull(refreshResult);
        Assert.NotEqual(loginResult.AccessToken, refreshResult.AccessToken);

        // Test protected endpoint with new token
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", refreshResult.AccessToken);

        var protectedResponse = await _client.GetAsync("/api/personality");
        Assert.Equal(HttpStatusCode.OK, protectedResponse.StatusCode);

        // Test logout
        var logoutResponse = await _client.PostAsync("/api/auth/logout", null);
        Assert.Equal(HttpStatusCode.OK, logoutResponse.StatusCode);
    }

    [Fact]
    public async Task AccountLockout_ShouldPreventBruteForceAttacks()
    {
        var loginRequest = new
        {
            Email = "user@test.com",
            Password = "WrongPassword123!"
        };

        // Attempt 5 failed logins
        for (int i = 0; i < 5; i++)
        {
            var response = await _client.PostAsJsonAsync("/api/auth/login", loginRequest);
            Assert.Equal(HttpStatusCode.BadRequest, response.StatusCode);
        }

        // 6th attempt should result in account lockout
        var lockedResponse = await _client.PostAsJsonAsync("/api/auth/login", loginRequest);
        Assert.Equal(HttpStatusCode.BadRequest, lockedResponse.StatusCode);

        var errorContent = await lockedResponse.Content.ReadAsStringAsync();
        Assert.Contains("locked", errorContent, StringComparison.OrdinalIgnoreCase);

        // Even correct password should be rejected during lockout
        var correctPasswordRequest = new
        {
            Email = "user@test.com",
            Password = "TestUser123!"
        };

        var correctResponse = await _client.PostAsJsonAsync("/api/auth/login", correctPasswordRequest);
        Assert.Equal(HttpStatusCode.BadRequest, correctResponse.StatusCode);
    }

    [Fact]
    public async Task JwtTokenValidation_ShouldEnforceProperClaims()
    {
        var token = await _fixture.GetAuthTokenAsync();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        // Test accessing user endpoint
        var userResponse = await _client.GetAsync("/api/personality");
        Assert.Equal(HttpStatusCode.OK, userResponse.StatusCode);

        // Test accessing admin endpoint without admin role
        var adminResponse = await _client.GetAsync("/api/metrics/dashboard");
        Assert.Equal(HttpStatusCode.Forbidden, adminResponse.StatusCode);

        // Test with admin token
        var adminToken = await _fixture.GetAdminTokenAsync();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", adminToken);

        var adminSuccessResponse = await _client.GetAsync("/api/metrics/dashboard");
        Assert.Equal(HttpStatusCode.OK, adminSuccessResponse.StatusCode);
    }
}
```

#### 1.3 Security Integration Tests
**File**: `tests/Integration/SecurityIntegrationTests.cs`
```csharp
[Collection("Integration Tests")]
public class SecurityIntegrationTests
{
    private readonly IntegrationTestFixture _fixture;
    private readonly HttpClient _client;

    public SecurityIntegrationTests(IntegrationTestFixture fixture)
    {
        _fixture = fixture;
        _client = fixture.Client;
    }

    [Fact]
    public async Task RateLimiting_ShouldEnforceApiLimits()
    {
        var token = await _fixture.GetAuthTokenAsync();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        // Make rapid requests to test rate limiting
        var tasks = new List<Task<HttpResponseMessage>>();
        for (int i = 0; i < 100; i++)
        {
            tasks.Add(_client.GetAsync("/api/personality"));
        }

        var responses = await Task.WhenAll(tasks);

        // Should have some 429 Too Many Requests responses
        var rateLimitedCount = responses.Count(r => r.StatusCode == HttpStatusCode.TooManyRequests);
        Assert.True(rateLimitedCount > 0, "Rate limiting should be enforced");

        // Check rate limit headers
        var rateLimitedResponse = responses.First(r => r.StatusCode == HttpStatusCode.TooManyRequests);
        Assert.True(rateLimitedResponse.Headers.Contains("X-RateLimit-Remaining"));
        Assert.True(rateLimitedResponse.Headers.Contains("Retry-After"));
    }

    [Theory]
    [InlineData("<script>alert('xss')</script>")]
    [InlineData("'; DROP TABLE Users; --")]
    [InlineData("{{7*7}}")]
    [InlineData("<img src=x onerror=alert('xss')>")]
    public async Task InputValidation_ShouldBlockMaliciousContent(string maliciousInput)
    {
        var token = await _fixture.GetAuthTokenAsync();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        var maliciousRequest = new
        {
            Name = maliciousInput,
            PersonalityData = new { trait = maliciousInput }
        };

        var response = await _client.PostAsJsonAsync("/api/personality", maliciousRequest);
        
        // Should be blocked by input validation
        Assert.Equal(HttpStatusCode.BadRequest, response.StatusCode);

        var errorContent = await response.Content.ReadAsStringAsync();
        Assert.Contains("threat", errorContent, StringComparison.OrdinalIgnoreCase);
    }

    [Fact]
    public async Task ApiKeyAuthentication_ShouldWorkProperly()
    {
        // Create API key first
        var adminToken = await _fixture.GetAdminTokenAsync();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", adminToken);

        var apiKeyRequest = new
        {
            Name = "Test API Key",
            Scope = "ReadOnly"
        };

        var createResponse = await _client.PostAsJsonAsync("/api/admin/apikeys", apiKeyRequest);
        Assert.Equal(HttpStatusCode.OK, createResponse.StatusCode);

        var apiKeyResult = await createResponse.Content.ReadFromJsonAsync<ApiKeyCreationResult>();
        Assert.NotNull(apiKeyResult?.ApiKey);

        // Test API key authentication
        _client.DefaultRequestHeaders.Clear();
        _client.DefaultRequestHeaders.Add("X-API-Key", apiKeyResult.ApiKey);

        var apiResponse = await _client.GetAsync("/api/personality");
        Assert.Equal(HttpStatusCode.OK, apiResponse.StatusCode);

        // Test invalid API key
        _client.DefaultRequestHeaders.Clear();
        _client.DefaultRequestHeaders.Add("X-API-Key", "invalid-key");

        var invalidResponse = await _client.GetAsync("/api/personality");
        Assert.Equal(HttpStatusCode.Unauthorized, invalidResponse.StatusCode);
    }

    [Fact]
    public async Task SecurityHeaders_ShouldBePresent()
    {
        var response = await _client.GetAsync("/api/health");
        
        // Check security headers
        Assert.True(response.Headers.Contains("X-Frame-Options"));
        Assert.True(response.Headers.Contains("X-Content-Type-Options"));
        Assert.True(response.Headers.Contains("Referrer-Policy"));
        
        // Check that sensitive headers are removed
        Assert.False(response.Headers.Contains("Server"));
        Assert.False(response.Headers.Contains("X-Powered-By"));
    }

    [Fact]
    public async Task CorsPolicy_ShouldBeEnforced()
    {
        // Test preflight request
        var preflightRequest = new HttpRequestMessage(HttpMethod.Options, "/api/personality");
        preflightRequest.Headers.Add("Origin", "https://malicious.com");
        preflightRequest.Headers.Add("Access-Control-Request-Method", "POST");

        var preflightResponse = await _client.SendAsync(preflightRequest);
        
        // Should reject unauthorized origins in production CORS policy
        Assert.False(preflightResponse.Headers.Contains("Access-Control-Allow-Origin") &&
                    preflightResponse.Headers.GetValues("Access-Control-Allow-Origin")
                        .Contains("https://malicious.com"));
    }
}
```

#### 1.4 Performance Integration Tests
**File**: `tests/Integration/PerformanceIntegrationTests.cs`
```csharp
[Collection("Integration Tests")]
public class PerformanceIntegrationTests
{
    private readonly IntegrationTestFixture _fixture;
    private readonly HttpClient _client;

    public PerformanceIntegrationTests(IntegrationTestFixture fixture)
    {
        _fixture = fixture;
        _client = fixture.Client;
    }

    [Fact]
    public async Task AuthenticationResponse_ShouldBeFasterThan200ms()
    {
        var loginRequest = new
        {
            Email = "user@test.com",
            Password = "TestUser123!"
        };

        var stopwatch = Stopwatch.StartNew();
        var response = await _client.PostAsJsonAsync("/api/auth/login", loginRequest);
        stopwatch.Stop();

        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
        Assert.True(stopwatch.ElapsedMilliseconds < 200, 
            $"Login took {stopwatch.ElapsedMilliseconds}ms, should be < 200ms");
    }

    [Fact]
    public async Task PersonalityGeneration_ShouldBeFasterThan2Seconds()
    {
        var token = await _fixture.GetAuthTokenAsync();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        var personalityRequest = new
        {
            Name = "Performance Test Profile",
            PersonalityData = new
            {
                traits = new { openness = 0.8, conscientiousness = 0.7 },
                preferences = new { style = "concise" }
            }
        };

        var stopwatch = Stopwatch.StartNew();
        var response = await _client.PostAsJsonAsync("/api/personality", personalityRequest);
        stopwatch.Stop();

        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
        Assert.True(stopwatch.ElapsedMilliseconds < 2000, 
            $"Personality generation took {stopwatch.ElapsedMilliseconds}ms, should be < 2000ms");
    }

    [Fact]
    public async Task DatabaseOperations_ShouldMaintainPerformance()
    {
        var token = await _fixture.GetAuthTokenAsync();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        // Test batch operations
        var tasks = new List<Task<HttpResponseMessage>>();
        var stopwatch = Stopwatch.StartNew();

        for (int i = 0; i < 50; i++)
        {
            tasks.Add(_client.GetAsync("/api/personality"));
        }

        var responses = await Task.WhenAll(tasks);
        stopwatch.Stop();

        // All requests should succeed
        Assert.All(responses, r => Assert.Equal(HttpStatusCode.OK, r.StatusCode));

        // Average response time should be reasonable
        var averageTime = stopwatch.ElapsedMilliseconds / 50.0;
        Assert.True(averageTime < 100, $"Average response time {averageTime}ms should be < 100ms");
    }

    [Fact]
    public async Task HealthChecks_ShouldRespondQuickly()
    {
        var endpoints = new[] { "/health", "/health/ready", "/health/live" };

        foreach (var endpoint in endpoints)
        {
            var stopwatch = Stopwatch.StartNew();
            var response = await _client.GetAsync(endpoint);
            stopwatch.Stop();

            Assert.Equal(HttpStatusCode.OK, response.StatusCode);
            Assert.True(stopwatch.ElapsedMilliseconds < 1000, 
                $"Health check {endpoint} took {stopwatch.ElapsedMilliseconds}ms, should be < 1000ms");
        }
    }
}
```

### Task 2: Load Testing Infrastructure (6 hours)

#### 2.1 Load Testing Framework
**File**: `tests/LoadTesting/LoadTestScenarios.cs`
```csharp
public class LoadTestScenarios
{
    private readonly string _baseUrl;
    private readonly string _adminToken;
    private readonly string _userToken;

    public LoadTestScenarios(string baseUrl)
    {
        _baseUrl = baseUrl;
        _adminToken = GetAuthToken("admin@test.com", "TestAdmin123!").Result;
        _userToken = GetAuthToken("user@test.com", "TestUser123!").Result;
    }

    private async Task<string> GetAuthToken(string email, string password)
    {
        using var client = new HttpClient { BaseAddress = new Uri(_baseUrl) };
        var loginRequest = new { Email = email, Password = password };
        
        var response = await client.PostAsJsonAsync("/api/auth/login", loginRequest);
        var result = await response.Content.ReadFromJsonAsync<AuthResponse>();
        
        return result!.AccessToken;
    }

    public Scenario CreateRealisticUserScenario() => Scenario.Create("realistic_user_behavior", async context =>
    {
        using var client = new HttpClient { BaseAddress = new Uri(_baseUrl) };
        client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", _userToken);

        var step = 0;
        
        // Step 1: Get personality profiles
        step++;
        using var getProfilesResponse = await client.GetAsync("/api/personality");
        
        return getProfilesResponse.IsSuccessStatusCode 
            ? Response.Ok(statusCode: (int)getProfilesResponse.StatusCode, sizeBytes: 1024)
            : Response.Fail($"Step {step} failed: {getProfilesResponse.StatusCode}");
    })
    .WithLoadSimulations(
        Simulation.InjectPerSec(rate: 10, during: TimeSpan.FromMinutes(1)), // Warm up
        Simulation.InjectPerSec(rate: 50, during: TimeSpan.FromMinutes(5)), // Normal load
        Simulation.InjectPerSec(rate: 100, during: TimeSpan.FromMinutes(2)), // Peak load
        Simulation.InjectPerSec(rate: 200, during: TimeSpan.FromMinutes(1)) // Stress test
    );

    public Scenario CreatePersonalityGenerationScenario() => Scenario.Create("personality_generation", async context =>
    {
        using var client = new HttpClient { BaseAddress = new Uri(_baseUrl) };
        client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", _userToken);

        var personalityRequest = new
        {
            Name = $"Load Test Profile {context.ScenarioInfo.ThreadId}",
            PersonalityData = new
            {
                traits = new
                {
                    openness = Random.Shared.NextDouble(),
                    conscientiousness = Random.Shared.NextDouble(),
                    extraversion = Random.Shared.NextDouble(),
                    agreeableness = Random.Shared.NextDouble(),
                    neuroticism = Random.Shared.NextDouble()
                },
                preferences = new
                {
                    communication_style = "professional",
                    response_length = "medium"
                }
            }
        };

        using var response = await client.PostAsJsonAsync("/api/personality", personalityRequest);
        
        return response.IsSuccessStatusCode 
            ? Response.Ok(statusCode: (int)response.StatusCode, sizeBytes: 2048)
            : Response.Fail($"Personality generation failed: {response.StatusCode}");
    })
    .WithLoadSimulations(
        Simulation.InjectPerSec(rate: 5, during: TimeSpan.FromMinutes(2)), // Gradual ramp
        Simulation.InjectPerSec(rate: 15, during: TimeSpan.FromMinutes(3)), // Sustained load
        Simulation.InjectPerSec(rate: 25, during: TimeSpan.FromMinutes(1)) // Peak generation load
    );

    public Scenario CreateAuthenticationLoadScenario() => Scenario.Create("authentication_load", async context =>
    {
        using var client = new HttpClient { BaseAddress = new Uri(_baseUrl) };

        // Simulate different users logging in
        var userIndex = context.ScenarioInfo.ThreadId % 100;
        var loginRequest = new
        {
            Email = $"loadtest{userIndex}@test.com",
            Password = "LoadTest123!"
        };

        using var response = await client.PostAsJsonAsync("/api/auth/login", loginRequest);
        
        if (response.IsSuccessStatusCode)
        {
            var authResult = await response.Content.ReadFromJsonAsync<AuthResponse>();
            
            // Use the token for a protected request
            client.DefaultRequestHeaders.Authorization = 
                new AuthenticationHeaderValue("Bearer", authResult!.AccessToken);
            
            using var protectedResponse = await client.GetAsync("/api/personality");
            
            return protectedResponse.IsSuccessStatusCode
                ? Response.Ok(statusCode: (int)protectedResponse.StatusCode, sizeBytes: 1024)
                : Response.Fail($"Protected request failed: {protectedResponse.StatusCode}");
        }

        return Response.Fail($"Login failed: {response.StatusCode}");
    })
    .WithLoadSimulations(
        Simulation.InjectPerSec(rate: 20, during: TimeSpan.FromMinutes(3)),
        Simulation.InjectPerSec(rate: 50, during: TimeSpan.FromMinutes(2)),
        Simulation.InjectPerSec(rate: 100, during: TimeSpan.FromMinutes(1))
    );

    public Scenario CreateMixedWorkloadScenario() => Scenario.Create("mixed_workload", async context =>
    {
        using var client = new HttpClient { BaseAddress = new Uri(_baseUrl) };
        client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", _userToken);

        // Randomly choose operation type
        var operation = Random.Shared.Next(0, 4);
        HttpResponseMessage response;

        switch (operation)
        {
            case 0: // Get profiles
                response = await client.GetAsync("/api/personality");
                break;
            case 1: // Get specific profile
                response = await client.GetAsync("/api/personality/1");
                break;
            case 2: // Health check
                response = await client.GetAsync("/health");
                break;
            case 3: // Metrics (if admin)
                client.DefaultRequestHeaders.Authorization = 
                    new AuthenticationHeaderValue("Bearer", _adminToken);
                response = await client.GetAsync("/api/metrics/dashboard");
                break;
            default:
                response = await client.GetAsync("/api/personality");
                break;
        }

        using (response)
        {
            return response.IsSuccessStatusCode 
                ? Response.Ok(statusCode: (int)response.StatusCode, sizeBytes: 1024)
                : Response.Fail($"Operation {operation} failed: {response.StatusCode}");
        }
    })
    .WithLoadSimulations(
        Simulation.KeepConstant(copies: 50, during: TimeSpan.FromMinutes(5)),
        Simulation.KeepConstant(copies: 100, during: TimeSpan.FromMinutes(3)),
        Simulation.KeepConstant(copies: 200, during: TimeSpan.FromMinutes(2))
    );
}

public class AuthResponse
{
    public string AccessToken { get; set; } = null!;
    public string RefreshToken { get; set; } = null!;
}
```

#### 2.2 Load Test Execution
**File**: `tests/LoadTesting/LoadTestRunner.cs`
```csharp
public class LoadTestRunner
{
    public static async Task RunLoadTests(string targetUrl)
    {
        Console.WriteLine("Starting DigitalMe Load Testing Suite");
        Console.WriteLine($"Target URL: {targetUrl}");
        Console.WriteLine("=====================================");

        var scenarios = new LoadTestScenarios(targetUrl);

        // Pre-test setup - create test users
        await SetupTestUsers(targetUrl);

        try
        {
            // Run individual scenario tests
            await RunScenario("Realistic User Behavior", scenarios.CreateRealisticUserScenario());
            await RunScenario("Personality Generation", scenarios.CreatePersonalityGenerationScenario());
            await RunScenario("Authentication Load", scenarios.CreateAuthenticationLoadScenario());
            
            // Run comprehensive mixed workload test
            Console.WriteLine("\nüöÄ Starting Mixed Workload Test (Main Performance Test)");
            var mixedWorkloadResults = await RunScenario("Mixed Workload", scenarios.CreateMixedWorkloadScenario());

            // Analyze results
            AnalyzeResults(mixedWorkloadResults);
            
            Console.WriteLine("\n‚úÖ Load testing completed successfully!");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"\n‚ùå Load testing failed: {ex.Message}");
            throw;
        }
    }

    private static async Task<NBomberStats> RunScenario(string name, Scenario scenario)
    {
        Console.WriteLine($"\nüìä Running {name} scenario...");
        
        var stats = NBomberRunner
            .RegisterScenarios(scenario)
            .WithWorkerPlugins(new PingPlugin())
            .WithReportFormats(ReportFormat.Html, ReportFormat.Csv, ReportFormat.Txt)
            .WithReportFolder($"load-test-results/{name.Replace(" ", "_").ToLower()}")
            .Run();

        Console.WriteLine($"‚úÖ {name} completed");
        Console.WriteLine($"   Success Rate: {stats.AllOkCount / (double)stats.AllRequestCount:P2}");
        Console.WriteLine($"   Avg Response Time: {stats.ScenarioStats[0].Ok.Response.Mean:F0}ms");
        Console.WriteLine($"   RPS: {stats.ScenarioStats[0].Ok.Request.Count / stats.TestDuration.TotalSeconds:F1}");

        return stats;
    }

    private static async Task SetupTestUsers(string baseUrl)
    {
        using var client = new HttpClient { BaseAddress = new Uri(baseUrl) };

        // Create 100 test users for load testing
        for (int i = 0; i < 100; i++)
        {
            var registerRequest = new
            {
                Email = $"loadtest{i}@test.com",
                FirstName = "Load",
                LastName = $"Test{i}",
                Password = "LoadTest123!"
            };

            try
            {
                await client.PostAsJsonAsync("/api/auth/register", registerRequest);
            }
            catch
            {
                // User might already exist, continue
            }
        }

        Console.WriteLine("‚úÖ Test users created");
    }

    private static void AnalyzeResults(NBomberStats stats)
    {
        Console.WriteLine("\nüìà Performance Analysis");
        Console.WriteLine("=====================");

        var scenarioStats = stats.ScenarioStats[0];
        var okStats = scenarioStats.Ok;
        var failStats = scenarioStats.Fail;

        // Success rate analysis
        var successRate = stats.AllOkCount / (double)stats.AllRequestCount;
        Console.WriteLine($"Overall Success Rate: {successRate:P2}");
        
        if (successRate < 0.995)
        {
            Console.WriteLine("‚ö†Ô∏è  Warning: Success rate below 99.5% target");
        }

        // Response time analysis
        Console.WriteLine($"\nResponse Times:");
        Console.WriteLine($"  Mean: {okStats.Response.Mean:F0}ms");
        Console.WriteLine($"  50th percentile: {okStats.Response.Percentile50:F0}ms");
        Console.WriteLine($"  95th percentile: {okStats.Response.Percentile95:F0}ms");
        Console.WriteLine($"  99th percentile: {okStats.Response.Percentile99:F0}ms");
        Console.WriteLine($"  Max: {okStats.Response.Max:F0}ms");

        if (okStats.Response.Percentile95 > 2000)
        {
            Console.WriteLine("‚ö†Ô∏è  Warning: 95th percentile response time above 2 seconds");
        }

        // Throughput analysis
        var rps = okStats.Request.Count / stats.TestDuration.TotalSeconds;
        Console.WriteLine($"\nThroughput: {rps:F1} requests/second");

        if (rps < 100)
        {
            Console.WriteLine("‚ö†Ô∏è  Warning: Throughput below expected 100 RPS minimum");
        }

        // Error analysis
        if (failStats.Request.Count > 0)
        {
            Console.WriteLine($"\nErrors: {failStats.Request.Count}");
            Console.WriteLine($"Error Rate: {failStats.Request.Count / (double)stats.AllRequestCount:P2}");
        }

        // Performance targets validation
        Console.WriteLine("\nüéØ Performance Targets Validation:");
        Console.WriteLine($"  ‚úÖ 500+ concurrent users supported: {scenarioStats.LoadSimulationStats.Max(s => s.Value) >= 500}");
        Console.WriteLine($"  ‚úÖ <2s response time (95th): {okStats.Response.Percentile95 < 2000}");
        Console.WriteLine($"  ‚úÖ 99.5%+ success rate: {successRate >= 0.995}");
        Console.WriteLine($"  ‚úÖ 100+ RPS throughput: {rps >= 100}");
    }
}

// NBomber plugin for network monitoring
public class PingPlugin : IWorkerPlugin
{
    public string PluginName => "Ping Monitor";

    public Task Init(IBaseContext context)
    {
        return Task.CompletedTask;
    }

    public Task Start()
    {
        return Task.CompletedTask;
    }

    public Task Stop()
    {
        return Task.CompletedTask;
    }

    public void Dispose()
    {
    }
}
```

#### 2.3 Load Test Configuration
**File**: `tests/LoadTesting/loadtest-config.json`
```json
{
  "NBomberConfig": {
    "TestSuite": "DigitalMe Production Load Test",
    "TargetScenarios": ["mixed_workload"],
    "GlobalSettings": {
      "ScenariosSettings": [
        {
          "ScenarioName": "mixed_workload",
          "WarmUpDuration": "00:00:30",
          "LoadSimulationsSettings": [
            {
              "LoadSimulationName": "inject_per_sec",
              "Rate": 50,
              "During": "00:02:00"
            },
            {
              "LoadSimulationName": "inject_per_sec", 
              "Rate": 100,
              "During": "00:03:00"
            },
            {
              "LoadSimulationName": "inject_per_sec",
              "Rate": 200,
              "During": "00:02:00"
            },
            {
              "LoadSimulationName": "inject_per_sec",
              "Rate": 500,
              "During": "00:01:00"
            }
          ]
        }
      ]
    }
  },
  "TestSettings": {
    "MaxConcurrentUsers": 500,
    "TestDurationMinutes": 10,
    "WarmUpDurationMinutes": 1,
    "AcceptableErrorRate": 0.005,
    "MaxResponseTimeMs": 2000,
    "MinThroughputRps": 100
  },
  "MonitoringSettings": {
    "EnableResourceMonitoring": true,
    "EnableNetworkLatencyCheck": true,
    "ReportInterval": "00:00:30"
  }
}
```

### Task 3: Security Vulnerability Assessment (5 hours)

#### 3.1 Automated Security Testing
**File**: `tests/Security/SecurityTestSuite.cs`
```csharp
public class SecurityTestSuite
{
    private readonly HttpClient _client;
    private readonly string _baseUrl;

    public SecurityTestSuite(string baseUrl)
    {
        _baseUrl = baseUrl;
        _client = new HttpClient { BaseAddress = new Uri(baseUrl) };
    }

    [Fact]
    public async Task SqlInjectionProtection_ShouldBlockAllCommonAttacks()
    {
        var sqlInjectionPayloads = new[]
        {
            "'; DROP TABLE Users; --",
            "' OR '1'='1",
            "1'; EXEC xp_cmdshell('dir'); --",
            "' UNION SELECT * FROM Users --",
            "'; UPDATE Users SET Password='hacked' WHERE '1'='1'; --"
        };

        var token = await GetAuthToken();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        foreach (var payload in sqlInjectionPayloads)
        {
            var maliciousRequest = new
            {
                Name = payload,
                PersonalityData = new { search = payload }
            };

            var response = await _client.PostAsJsonAsync("/api/personality", maliciousRequest);
            
            // Should be blocked by input validation
            Assert.NotEqual(HttpStatusCode.OK, response.StatusCode);
            
            var content = await response.Content.ReadAsStringAsync();
            Assert.DoesNotContain("syntax error", content, StringComparison.OrdinalIgnoreCase);
            Assert.DoesNotContain("database", content, StringComparison.OrdinalIgnoreCase);
        }
    }

    [Fact] 
    public async Task XssProtection_ShouldPreventScriptInjection()
    {
        var xssPayloads = new[]
        {
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "<body onload=alert('XSS')>",
            "{{7*7}}",
            "${7*7}",
            "<%=7*7%>"
        };

        var token = await GetAuthToken();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        foreach (var payload in xssPayloads)
        {
            var maliciousRequest = new
            {
                Name = payload,
                PersonalityData = new { description = payload }
            };

            var response = await _client.PostAsJsonAsync("/api/personality", maliciousRequest);
            
            // Should be blocked or sanitized
            if (response.IsSuccessStatusCode)
            {
                var profile = await response.Content.ReadFromJsonAsync<dynamic>();
                var name = profile?.Name?.ToString() ?? "";
                
                // Should be HTML encoded/sanitized
                Assert.DoesNotContain("<script", name, StringComparison.OrdinalIgnoreCase);
                Assert.DoesNotContain("javascript:", name, StringComparison.OrdinalIgnoreCase);
                Assert.DoesNotContain("onerror=", name, StringComparison.OrdinalIgnoreCase);
            }
            else
            {
                // Blocked by validation is also acceptable
                Assert.Equal(HttpStatusCode.BadRequest, response.StatusCode);
            }
        }
    }

    [Fact]
    public async Task AuthorizationBypass_ShouldNotAllowElevation()
    {
        var token = await GetAuthToken(); // Regular user token
        
        // Try to access admin endpoints
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        var adminEndpoints = new[]
        {
            "/api/admin/users",
            "/api/metrics/dashboard", 
            "/api/admin/apikeys",
            "/api/admin/system"
        };

        foreach (var endpoint in adminEndpoints)
        {
            var response = await _client.GetAsync(endpoint);
            
            // Should be forbidden for regular users
            Assert.Equal(HttpStatusCode.Forbidden, response.StatusCode);
        }
    }

    [Fact]
    public async Task SessionManagement_ShouldEnforceSecureTokenHandling()
    {
        // Test 1: Invalid token should be rejected
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", "invalid.jwt.token");
        
        var response = await _client.GetAsync("/api/personality");
        Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);

        // Test 2: Expired token should be rejected
        var expiredToken = GenerateExpiredToken();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", expiredToken);
        
        response = await _client.GetAsync("/api/personality");
        Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);

        // Test 3: Valid token should work
        var validToken = await GetAuthToken();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", validToken);
        
        response = await _client.GetAsync("/api/personality");
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    }

    [Fact]
    public async Task PasswordSecurity_ShouldEnforceStrongPolicies()
    {
        var weakPasswords = new[]
        {
            "password", // Common password
            "123456", // Numeric only
            "abc", // Too short
            "PASSWORD", // No complexity
            "password123", // No special chars
            "Password", // No numbers/special chars
        };

        foreach (var weakPassword in weakPasswords)
        {
            var registerRequest = new
            {
                Email = $"test_{Guid.NewGuid()}@test.com",
                FirstName = "Test",
                LastName = "User",
                Password = weakPassword
            };

            var response = await _client.PostAsJsonAsync("/api/auth/register", registerRequest);
            
            // Weak passwords should be rejected
            Assert.Equal(HttpStatusCode.BadRequest, response.StatusCode);
            
            var content = await response.Content.ReadAsStringAsync();
            Assert.Contains("password", content, StringComparison.OrdinalIgnoreCase);
        }
    }

    [Fact]
    public async Task DataExposure_ShouldNotLeakSensitiveInformation()
    {
        // Test error responses don't expose sensitive data
        var response = await _client.GetAsync("/api/personality/99999");
        
        if (response.StatusCode == HttpStatusCode.NotFound)
        {
            var content = await response.Content.ReadAsStringAsync();
            
            // Should not expose database info, file paths, etc.
            Assert.DoesNotContain("database", content, StringComparison.OrdinalIgnoreCase);
            Assert.DoesNotContain("exception", content, StringComparison.OrdinalIgnoreCase);
            Assert.DoesNotContain("stack trace", content, StringComparison.OrdinalIgnoreCase);
            Assert.DoesNotContain("C:\\", content);
            Assert.DoesNotContain("/app/", content);
        }
    }

    [Fact]
    public async Task FileUploadSecurity_ShouldValidateUploads()
    {
        var maliciousFiles = new[]
        {
            ("malicious.exe", "application/octet-stream", new byte[] { 0x4D, 0x5A }), // PE header
            ("script.php", "text/plain", Encoding.UTF8.GetBytes("<?php system($_GET['cmd']); ?>")),
            ("large.txt", "text/plain", new byte[100 * 1024 * 1024]) // 100MB file
        };

        var token = await GetAuthToken();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        foreach (var (filename, contentType, content) in maliciousFiles)
        {
            var formData = new MultipartFormDataContent();
            formData.Add(new ByteArrayContent(content), "file", filename);

            var response = await _client.PostAsync("/api/upload", formData);
            
            // Should reject malicious uploads
            Assert.NotEqual(HttpStatusCode.OK, response.StatusCode);
        }
    }

    [Fact]
    public async Task ApiRateLimiting_ShouldPreventAbuse()
    {
        var token = await GetAuthToken();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        // Make rapid requests to trigger rate limiting
        var tasks = new List<Task<HttpResponseMessage>>();
        for (int i = 0; i < 200; i++)
        {
            tasks.Add(_client.GetAsync("/api/personality"));
        }

        var responses = await Task.WhenAll(tasks);
        
        // Some requests should be rate limited
        var rateLimitedCount = responses.Count(r => r.StatusCode == HttpStatusCode.TooManyRequests);
        Assert.True(rateLimitedCount > 0, "Rate limiting should be active");

        // Rate limited responses should have proper headers
        var rateLimitedResponse = responses.First(r => r.StatusCode == HttpStatusCode.TooManyRequests);
        Assert.True(rateLimitedResponse.Headers.Contains("Retry-After"));
    }

    private async Task<string> GetAuthToken()
    {
        var loginRequest = new
        {
            Email = "user@test.com", 
            Password = "TestUser123!"
        };

        var response = await _client.PostAsJsonAsync("/api/auth/login", loginRequest);
        var result = await response.Content.ReadFromJsonAsync<AuthResponse>();
        
        return result!.AccessToken;
    }

    private string GenerateExpiredToken()
    {
        // Generate a JWT token that's already expired
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes("TestSecretKeyThatIsLongEnoughFor256Bits!");
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[] { new Claim(ClaimTypes.NameIdentifier, "1") }),
            Expires = DateTime.UtcNow.AddMinutes(-30), // Expired 30 minutes ago
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), 
                SecurityAlgorithms.HmacSha256Signature)
        };

        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}

public class AuthResponse
{
    public string AccessToken { get; set; } = null!;
    public string RefreshToken { get; set; } = null!;
}
```

### Task 4: Database Integrity & Disaster Recovery Testing (3 hours)

#### 4.1 Database Integrity Tests
**File**: `tests/Integration/DatabaseIntegrityTests.cs`
```csharp
[Collection("Integration Tests")]
public class DatabaseIntegrityTests
{
    private readonly IntegrationTestFixture _fixture;
    private readonly ApplicationDbContext _dbContext;

    public DatabaseIntegrityTests(IntegrationTestFixture fixture)
    {
        _fixture = fixture;
        _dbContext = fixture.Scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
    }

    [Fact]
    public async Task DatabaseSchema_ShouldMaintainIntegrity()
    {
        // Test that all expected tables exist
        var tableNames = new[]
        {
            "Users", "PersonalityProfiles", "ApiKeys", "__EFMigrationsHistory"
        };

        foreach (var tableName in tableNames)
        {
            var sql = $"SELECT COUNT(*) FROM information_schema.tables WHERE table_name = '{tableName.ToLowerInvariant()}'";
            var count = await _dbContext.Database.SqlQueryRaw<int>(sql).FirstAsync();
            Assert.Equal(1, count, $"Table {tableName} should exist");
        }
    }

    [Fact]
    public async Task ForeignKeyConstraints_ShouldBeEnforced()
    {
        // Test PersonalityProfile -> User foreign key
        var invalidProfile = new PersonalityProfile
        {
            Name = "Invalid Profile",
            OwnerId = 99999, // Non-existent user ID
            PersonalityData = JsonDocument.Parse("{}")
        };

        _dbContext.PersonalityProfiles.Add(invalidProfile);
        
        // Should throw foreign key constraint violation
        await Assert.ThrowsAsync<DbUpdateException>(async () => 
            await _dbContext.SaveChangesAsync());
    }

    [Fact]
    public async Task UniqueConstraints_ShouldBeEnforced()
    {
        // Test unique email constraint
        var user1 = new User
        {
            Email = "duplicate@test.com",
            FirstName = "User",
            LastName = "One",
            PasswordHash = "hash1"
        };

        var user2 = new User
        {
            Email = "duplicate@test.com", // Same email
            FirstName = "User",
            LastName = "Two",
            PasswordHash = "hash2"
        };

        _dbContext.Users.AddRange(user1, user2);
        
        // Should throw unique constraint violation
        await Assert.ThrowsAsync<DbUpdateException>(async () => 
            await _dbContext.SaveChangesAsync());
    }

    [Fact]
    public async Task AuditTrail_ShouldTrackChanges()
    {
        // Create a user
        var user = new User
        {
            Email = "audit@test.com",
            FirstName = "Audit",
            LastName = "Test",
            PasswordHash = "hash",
            CreatedAt = DateTime.UtcNow,
            CreatedBy = 1
        };

        _dbContext.Users.Add(user);
        await _dbContext.SaveChangesAsync();

        // Verify audit fields are set
        Assert.True(user.Id > 0);
        Assert.True(user.CreatedAt > DateTime.UtcNow.AddMinutes(-1));
        Assert.Equal(1, user.CreatedBy);

        // Update the user
        user.FirstName = "Updated";
        user.UpdatedAt = DateTime.UtcNow;
        user.UpdatedBy = 2;

        await _dbContext.SaveChangesAsync();

        // Verify update audit fields
        Assert.NotNull(user.UpdatedAt);
        Assert.Equal(2, user.UpdatedBy);
        Assert.True(user.UpdatedAt > user.CreatedAt);
    }

    [Fact]
    public async Task DatabaseBackup_ShouldMaintainDataIntegrity()
    {
        // Create test data
        var testUser = new User
        {
            Email = "backup@test.com",
            FirstName = "Backup",
            LastName = "Test",
            PasswordHash = "hash"
        };

        _dbContext.Users.Add(testUser);
        await _dbContext.SaveChangesAsync();

        var originalUserId = testUser.Id;

        // Simulate backup and restore process
        // In a real scenario, this would involve actual database backup/restore
        
        // Verify data exists after "restore"
        var restoredUser = await _dbContext.Users
            .FirstOrDefaultAsync(u => u.Id == originalUserId);
        
        Assert.NotNull(restoredUser);
        Assert.Equal("backup@test.com", restoredUser.Email);
        Assert.Equal("Backup", restoredUser.FirstName);
    }

    [Fact]
    public async Task DatabaseConnections_ShouldHandleConnectionPooling()
    {
        // Test multiple concurrent database operations
        var tasks = new List<Task>();

        for (int i = 0; i < 20; i++)
        {
            var taskId = i;
            tasks.Add(Task.Run(async () =>
            {
                using var scope = _fixture.Factory.Services.CreateScope();
                var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
                
                // Perform database operation
                var count = await context.Users.CountAsync();
                
                // Create a user
                var user = new User
                {
                    Email = $"concurrent{taskId}@test.com",
                    FirstName = "Concurrent",
                    LastName = $"Test{taskId}",
                    PasswordHash = "hash"
                };

                context.Users.Add(user);
                await context.SaveChangesAsync();
            }));
        }

        // All operations should complete without deadlocks
        await Task.WhenAll(tasks);

        // Verify all users were created
        var concurrentUsers = await _dbContext.Users
            .Where(u => u.Email.StartsWith("concurrent"))
            .CountAsync();
        
        Assert.Equal(20, concurrentUsers);
    }

    [Fact]
    public async Task JsonDataIntegrity_ShouldMaintainStructure()
    {
        // Test JSONB data storage and retrieval
        var complexPersonalityData = new
        {
            traits = new
            {
                openness = 0.85,
                conscientiousness = 0.72,
                extraversion = 0.63,
                agreeableness = 0.91,
                neuroticism = 0.28
            },
            preferences = new
            {
                communication_style = "professional",
                response_length = "detailed",
                topics_of_interest = new[] { "technology", "psychology", "philosophy" }
            },
            metadata = new
            {
                created_by_system = "DigitalMe",
                version = "3.1.0",
                last_analysis = DateTime.UtcNow
            }
        };

        var profile = new PersonalityProfile
        {
            Name = "JSON Integrity Test",
            OwnerId = 1,
            PersonalityData = JsonDocument.Parse(JsonSerializer.Serialize(complexPersonalityData))
        };

        _dbContext.PersonalityProfiles.Add(profile);
        await _dbContext.SaveChangesAsync();

        // Retrieve and verify JSON structure
        var retrievedProfile = await _dbContext.PersonalityProfiles
            .FirstAsync(p => p.Id == profile.Id);

        var retrievedData = retrievedProfile.PersonalityData.RootElement;
        
        // Verify complex nested structure is preserved
        Assert.Equal(0.85, retrievedData.GetProperty("traits").GetProperty("openness").GetDouble());
        Assert.Equal("professional", retrievedData.GetProperty("preferences").GetProperty("communication_style").GetString());
        Assert.Equal(3, retrievedData.GetProperty("preferences").GetProperty("topics_of_interest").GetArrayLength());
    }
}
```

### Task 5: Production Deployment Validation (3 hours)

#### 5.1 Deployment Validation Test Suite
**File**: `tests/Deployment/DeploymentValidationTests.cs`
```csharp
public class DeploymentValidationTests
{
    private readonly string _productionUrl;
    private readonly string _stagingUrl;
    private readonly HttpClient _client;

    public DeploymentValidationTests()
    {
        _productionUrl = Environment.GetEnvironmentVariable("PRODUCTION_URL") 
                        ?? "https://digitalme.com";
        _stagingUrl = Environment.GetEnvironmentVariable("STAGING_URL") 
                     ?? "https://staging.digitalme.com";
        _client = new HttpClient();
    }

    [Fact]
    public async Task HealthEndpoints_ShouldBeAccessible()
    {
        var endpoints = new[] { "/health", "/health/ready", "/health/live" };
        var environments = new[] { _stagingUrl, _productionUrl };

        foreach (var environment in environments)
        {
            _client.BaseAddress = new Uri(environment);
            
            foreach (var endpoint in endpoints)
            {
                var response = await _client.GetAsync(endpoint);
                
                Assert.Equal(HttpStatusCode.OK, response.StatusCode);
                
                var content = await response.Content.ReadAsStringAsync();
                Assert.Contains("Healthy", content, StringComparison.OrdinalIgnoreCase);
            }
        }
    }

    [Fact]
    public async Task SslCertificate_ShouldBeValid()
    {
        using var handler = new HttpClientHandler()
        {
            ServerCertificateCustomValidationCallback = (request, cert, chain, errors) =>
            {
                // Validate certificate in production
                if (_client.BaseAddress?.Host == new Uri(_productionUrl).Host)
                {
                    return errors == SslPolicyErrors.None;
                }
                return true; // Allow staging certificates
            }
        };

        using var sslClient = new HttpClient(handler);
        
        sslClient.BaseAddress = new Uri(_productionUrl);
        var response = await sslClient.GetAsync("/health");
        
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    }

    [Fact]
    public async Task SecurityHeaders_ShouldBePresentInProduction()
    {
        _client.BaseAddress = new Uri(_productionUrl);
        var response = await _client.GetAsync("/health");
        
        // Verify security headers
        var headers = response.Headers.Concat(response.Content.Headers);
        var headerDict = headers.ToDictionary(h => h.Key, h => string.Join(", ", h.Value));
        
        Assert.True(headerDict.ContainsKey("Strict-Transport-Security"));
        Assert.True(headerDict.ContainsKey("X-Frame-Options"));
        Assert.True(headerDict.ContainsKey("X-Content-Type-Options"));
        Assert.True(headerDict.ContainsKey("Referrer-Policy"));
        
        // Verify HSTS header
        Assert.Contains("max-age=", headerDict["Strict-Transport-Security"]);
        
        // Verify other security headers
        Assert.Equal("DENY", headerDict["X-Frame-Options"]);
        Assert.Equal("nosniff", headerDict["X-Content-Type-Options"]);
    }

    [Fact]
    public async Task DatabaseMigrations_ShouldBeApplied()
    {
        // This test would typically connect to the production database
        // and verify that all expected migrations have been applied
        
        var migrationEndpoint = "/api/admin/database/migrations";
        _client.BaseAddress = new Uri(_stagingUrl);
        
        // Add admin authentication
        var adminToken = await GetAdminToken(_stagingUrl);
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", adminToken);
        
        var response = await _client.GetAsync(migrationEndpoint);
        
        if (response.StatusCode == HttpStatusCode.OK)
        {
            var migrations = await response.Content.ReadFromJsonAsync<string[]>();
            
            // Verify expected migrations are present
            var expectedMigrations = new[]
            {
                "AddUserAuthentication",
                "AddPersonalityProfiles", 
                "AddApiKeys",
                // Add other expected migration names
            };

            foreach (var expectedMigration in expectedMigrations)
            {
                Assert.Contains(migrations!, m => m.Contains(expectedMigration));
            }
        }
    }

    [Fact]
    public async Task LoadBalancer_ShouldDistributeTraffic()
    {
        _client.BaseAddress = new Uri(_productionUrl);
        
        var responses = new List<HttpResponseMessage>();
        
        // Make multiple requests to see if they hit different instances
        for (int i = 0; i < 20; i++)
        {
            var response = await _client.GetAsync("/api/health");
            responses.Add(response);
        }

        // Check if responses come from different server instances
        // (This would be indicated by different server headers or instance IDs)
        var serverHeaders = responses
            .Where(r => r.Headers.Contains("X-Instance-Id"))
            .Select(r => r.Headers.GetValues("X-Instance-Id").First())
            .Distinct()
            .ToList();

        // In a load-balanced setup, we should see multiple instance IDs
        // For a single instance setup, this test might be skipped
        if (serverHeaders.Count > 1)
        {
            Assert.True(serverHeaders.Count >= 2, "Load balancer should distribute to multiple instances");
        }
    }

    [Fact]
    public async Task BlueGreenDeployment_ShouldEnableZeroDowntime()
    {
        // This test simulates the blue-green deployment process
        var deploymentStartTime = DateTime.UtcNow;
        var maxDowntimeAllowed = TimeSpan.FromSeconds(5);
        
        _client.BaseAddress = new Uri(_stagingUrl);
        
        // Monitor availability during deployment simulation
        var monitoringTask = Task.Run(async () =>
        {
            var downtime = TimeSpan.Zero;
            var lastFailureTime = DateTime.MinValue;
            
            while (DateTime.UtcNow - deploymentStartTime < TimeSpan.FromMinutes(2))
            {
                try
                {
                    var response = await _client.GetAsync("/health/live");
                    if (!response.IsSuccessStatusCode)
                    {
                        if (lastFailureTime == DateTime.MinValue)
                        {
                            lastFailureTime = DateTime.UtcNow;
                        }
                    }
                    else if (lastFailureTime != DateTime.MinValue)
                    {
                        downtime += DateTime.UtcNow - lastFailureTime;
                        lastFailureTime = DateTime.MinValue;
                    }
                }
                catch
                {
                    if (lastFailureTime == DateTime.MinValue)
                    {
                        lastFailureTime = DateTime.UtcNow;
                    }
                }
                
                await Task.Delay(100); // Check every 100ms
            }
            
            if (lastFailureTime != DateTime.MinValue)
            {
                downtime += DateTime.UtcNow - lastFailureTime;
            }
            
            return downtime;
        });

        // Wait for monitoring to complete
        var totalDowntime = await monitoringTask;
        
        Assert.True(totalDowntime < maxDowntimeAllowed, 
            $"Downtime {totalDowntime.TotalSeconds}s exceeded maximum allowed {maxDowntimeAllowed.TotalSeconds}s");
    }

    [Fact]
    public async Task Configuration_ShouldBeEnvironmentSpecific()
    {
        // Test that production and staging have different configurations
        var stagingConfig = await GetConfiguration(_stagingUrl);
        var productionConfig = await GetConfiguration(_productionUrl);

        // Environment names should be different
        Assert.NotEqual(stagingConfig.Environment, productionConfig.Environment);
        
        // Database connections should be different
        Assert.NotEqual(stagingConfig.DatabaseConnection, productionConfig.DatabaseConnection);
        
        // Application Insights keys should be different (if configured)
        if (!string.IsNullOrEmpty(stagingConfig.ApplicationInsights) && 
            !string.IsNullOrEmpty(productionConfig.ApplicationInsights))
        {
            Assert.NotEqual(stagingConfig.ApplicationInsights, productionConfig.ApplicationInsights);
        }
    }

    [Fact]
    public async Task Rollback_ShouldBeQuickAndReliable()
    {
        // Test rollback capability by deploying to staging slot and rolling back
        _client.BaseAddress = new Uri(_stagingUrl);
        
        var adminToken = await GetAdminToken(_stagingUrl);
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", adminToken);

        // Get current deployment info
        var currentDeploymentResponse = await _client.GetAsync("/api/admin/deployment/current");
        var currentDeployment = await currentDeploymentResponse.Content.ReadFromJsonAsync<DeploymentInfo>();

        // Simulate rollback trigger
        var rollbackResponse = await _client.PostAsync("/api/admin/deployment/rollback", null);
        
        if (rollbackResponse.StatusCode == HttpStatusCode.OK)
        {
            // Wait for rollback to complete
            await Task.Delay(TimeSpan.FromSeconds(30));
            
            // Verify system is still accessible
            var healthResponse = await _client.GetAsync("/health/ready");
            Assert.Equal(HttpStatusCode.OK, healthResponse.StatusCode);
            
            // Verify rollback completed quickly (should be < 2 minutes)
            var rollbackEndTime = DateTime.UtcNow;
            var rollbackDuration = rollbackEndTime - DateTime.UtcNow.AddSeconds(-30);
            
            Assert.True(rollbackDuration < TimeSpan.FromMinutes(2), 
                "Rollback should complete within 2 minutes");
        }
    }

    private async Task<string> GetAdminToken(string baseUrl)
    {
        using var authClient = new HttpClient { BaseAddress = new Uri(baseUrl) };
        
        var loginRequest = new
        {
            Email = Environment.GetEnvironmentVariable("TEST_ADMIN_EMAIL") ?? "admin@test.com",
            Password = Environment.GetEnvironmentVariable("TEST_ADMIN_PASSWORD") ?? "TestAdmin123!"
        };

        var response = await authClient.PostAsJsonAsync("/api/auth/login", loginRequest);
        var result = await response.Content.ReadFromJsonAsync<AuthResponse>();
        
        return result!.AccessToken;
    }

    private async Task<EnvironmentConfig> GetConfiguration(string baseUrl)
    {
        using var configClient = new HttpClient { BaseAddress = new Uri(baseUrl) };
        
        var adminToken = await GetAdminToken(baseUrl);
        configClient.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", adminToken);
        
        var response = await configClient.GetAsync("/api/admin/configuration");
        return await response.Content.ReadFromJsonAsync<EnvironmentConfig>() 
               ?? new EnvironmentConfig();
    }
}

public class DeploymentInfo
{
    public string Version { get; set; } = null!;
    public DateTime DeployedAt { get; set; }
    public string Environment { get; set; } = null!;
}

public class EnvironmentConfig
{
    public string Environment { get; set; } = null!;
    public string DatabaseConnection { get; set; } = null!;
    public string ApplicationInsights { get; set; } = null!;
}

public class AuthResponse
{
    public string AccessToken { get; set; } = null!;
    public string RefreshToken { get; set; } = null!;
}
```

---

## ‚úÖ VALIDATION & TESTING

### Test Execution Commands
```bash
# Run integration tests
dotnet test tests/Integration --configuration Release

# Run load tests
dotnet run --project tests/LoadTesting -- --target-url https://staging.digitalme.com

# Run security tests
dotnet test tests/Security --configuration Release

# Run database integrity tests
dotnet test tests/Integration --filter Category=DatabaseIntegrity

# Run deployment validation tests
dotnet test tests/Deployment --configuration Release
```

### Continuous Testing Pipeline
```yaml
# .github/workflows/production-testing.yml
name: Production Testing Suite

on:
  schedule:
    - cron: '0 */4 * * *' # Every 4 hours
  workflow_dispatch:

jobs:
  production-health-check:
    runs-on: ubuntu-latest
    steps:
      - name: Health Check Production
        run: |
          curl -f https://digitalme.com/health/ready
          curl -f https://digitalme.com/health/live
  
  integration-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0'
      - name: Run Integration Tests
        run: dotnet test tests/Integration --configuration Release
  
  load-tests:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4
      - name: Run Load Tests
        run: dotnet run --project tests/LoadTesting
```

---

## üîó INTEGRATION POINTS

### Complete P3.1 System Validation
- **P3.1.1 Authentication**: JWT tokens, user management, role-based access tested
- **P3.1.2 Security**: Rate limiting, input validation, API keys validated under load
- **P3.1.3 Monitoring**: Metrics collection, health checks, alerting validated
- **P3.1.4 Deployment**: Blue-green deployment, rollback procedures tested

### P2.1-P2.4 Compatibility Verification
- **Personality Engine**: Existing functionality preserved and enhanced
- **Database Schema**: Migrations applied without breaking existing data
- **API Contracts**: Backward compatibility maintained for existing endpoints
- **Performance**: P2.1-P2.4 functionality meets performance targets under load

### Production Readiness Validation
- **500+ Concurrent Users**: Load testing validates concurrent user support
- **99.5%+ Uptime**: Health monitoring and alerting ensure uptime targets
- **<2s Response Times**: Performance testing validates response time targets
- **Zero Critical Vulnerabilities**: Security testing ensures no critical issues
- **Zero-Downtime Deployment**: Blue-green deployment validation confirms capability

---

**COMPONENT SUMMARY**: P3.1.5 provides comprehensive production integration testing with end-to-end validation, load testing up to 500+ concurrent users, security vulnerability assessment, database integrity testing, and deployment validation. Ensures complete production readiness for DigitalMe system.

**CRITICAL SUCCESS FACTORS**: All P3.1 components integrated seamlessly, performance targets met under load, zero critical security vulnerabilities, database integrity maintained, deployment procedures validated, P2.1-P2.4 compatibility preserved.