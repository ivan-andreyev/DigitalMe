# P3.1.1 JWT Authentication System

**Parent Plan**: [P3.1-Production-Readiness-Foundation-Plan.md](../P3.1-Production-Readiness-Foundation-Plan.md)  
**Timeline**: Week 1-2 (15 hours) | **Priority**: CRITICAL | **Dependencies**: None

## ðŸŽ¯ COMPONENT MISSION

Transform existing basic authentication into enterprise-grade JWT-based user management with role-based access control, supporting the DigitalMe personality engine's production security requirements.

**Success Criteria**: <200ms auth response, secure token management, audit trail integration

---

## ðŸ“Š CURRENT STATE ANALYSIS

### Existing P2.1-P2.4 Assets
âœ… **BaseEntity.cs** - Basic audit fields (CreatedBy, UpdatedBy)  
âœ… **PostgreSQL Context** - Database foundation ready  
âœ… **Basic Controllers** - Auth controller structure exists  
âŒ **JWT Implementation** - Missing secure token management  
âŒ **User Management** - No user roles or account security  
âŒ **Password Security** - No encryption or account protection  

### Integration Requirements
- **PersonalityProfile.cs**: Add OwnerId foreign key for user-specific profiles
- **ClaudeApiService.cs**: Add user validation for API calls
- **Existing Controllers**: JWT protection middleware integration
- **BaseEntity.cs**: Enhanced audit trail with user context

---

## ðŸ”§ IMPLEMENTATION TASKS

### Task 1: User Management Infrastructure (4 hours)

#### 1.1 Create User Entity Model
**File**: `src/Core/Entities/User.cs`
```csharp
public class User : BaseEntity
{
    public int Id { get; set; }
    public string Email { get; set; } = null!;
    public string FirstName { get; set; } = null!;
    public string LastName { get; set; } = null!;
    public string PasswordHash { get; set; } = null!;
    public string? RefreshToken { get; set; }
    public DateTime? RefreshTokenExpiryTime { get; set; }
    public bool IsActive { get; set; } = true;
    public bool IsEmailConfirmed { get; set; } = false;
    public string? EmailConfirmationToken { get; set; }
    public DateTime? LastLoginDate { get; set; }
    public int FailedLoginAttempts { get; set; } = 0;
    public DateTime? AccountLockedUntil { get; set; }
    public UserRole Role { get; set; } = UserRole.User;
}

public enum UserRole
{
    User = 0,
    Admin = 1,
    SuperAdmin = 2
}
```

#### 1.2 Update Database Context
**File**: `src/Infrastructure/Data/ApplicationDbContext.cs`
```csharp
public DbSet<User> Users { get; set; }

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);
    
    modelBuilder.Entity<User>(entity =>
    {
        entity.HasKey(e => e.Id);
        entity.HasIndex(e => e.Email).IsUnique();
        entity.Property(e => e.Email).IsRequired().HasMaxLength(256);
        entity.Property(e => e.FirstName).IsRequired().HasMaxLength(100);
        entity.Property(e => e.LastName).IsRequired().HasMaxLength(100);
        entity.Property(e => e.PasswordHash).IsRequired();
        entity.Property(e => e.Role).HasConversion<string>();
    });
}
```

#### 1.3 Database Migration
```bash
# Generate and apply migration
dotnet ef migrations add AddUserAuthentication
dotnet ef database update
```

### Task 2: JWT Service Implementation (5 hours)

#### 2.1 JWT Configuration
**File**: `src/Infrastructure/Authentication/JwtSettings.cs`
```csharp
public class JwtSettings
{
    public string SecretKey { get; set; } = null!;
    public string Issuer { get; set; } = null!;
    public string Audience { get; set; } = null!;
    public int TokenExpiryMinutes { get; set; } = 60;
    public int RefreshTokenExpiryDays { get; set; } = 7;
}
```

#### 2.2 JWT Service Interface
**File**: `src/Core/Interfaces/IJwtService.cs`
```csharp
public interface IJwtService
{
    string GenerateAccessToken(User user);
    string GenerateRefreshToken();
    ClaimsPrincipal? GetPrincipalFromExpiredToken(string token);
    Task<AuthResult> RefreshTokenAsync(string token, string refreshToken);
    Task RevokeRefreshTokenAsync(int userId);
}

public class AuthResult
{
    public bool Success { get; set; }
    public string? AccessToken { get; set; }
    public string? RefreshToken { get; set; }
    public string? Error { get; set; }
    public User? User { get; set; }
}
```

#### 2.3 JWT Service Implementation
**File**: `src/Infrastructure/Authentication/JwtService.cs`
```csharp
public class JwtService : IJwtService
{
    private readonly JwtSettings _jwtSettings;
    private readonly IUserRepository _userRepository;
    private readonly ILogger<JwtService> _logger;

    public string GenerateAccessToken(User user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_jwtSettings.SecretKey);
        
        var claims = new List<Claim>
        {
            new(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new(ClaimTypes.Email, user.Email),
            new(ClaimTypes.Name, $"{user.FirstName} {user.LastName}"),
            new(ClaimTypes.Role, user.Role.ToString()),
            new("jti", Guid.NewGuid().ToString())
        };

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddMinutes(_jwtSettings.TokenExpiryMinutes),
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), 
                SecurityAlgorithms.HmacSha256Signature),
            Issuer = _jwtSettings.Issuer,
            Audience = _jwtSettings.Audience
        };

        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }

    public string GenerateRefreshToken()
    {
        var randomNumber = new byte[32];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(randomNumber);
        return Convert.ToBase64String(randomNumber);
    }

    // Additional methods implementation...
}
```

### Task 3: Authentication Services (3 hours)

#### 3.1 Password Service
**File**: `src/Infrastructure/Authentication/PasswordService.cs`
```csharp
public interface IPasswordService
{
    string HashPassword(string password);
    bool VerifyPassword(string password, string hash);
}

public class PasswordService : IPasswordService
{
    public string HashPassword(string password)
    {
        return BCrypt.Net.BCrypt.HashPassword(password, workFactor: 12);
    }

    public bool VerifyPassword(string password, string hash)
    {
        return BCrypt.Net.BCrypt.Verify(password, hash);
    }
}
```

#### 3.2 User Repository
**File**: `src/Infrastructure/Repositories/UserRepository.cs`
```csharp
public interface IUserRepository : IGenericRepository<User>
{
    Task<User?> GetByEmailAsync(string email);
    Task<bool> EmailExistsAsync(string email);
    Task UpdateRefreshTokenAsync(int userId, string refreshToken, DateTime expiryTime);
    Task IncrementFailedLoginAttemptsAsync(int userId);
    Task ResetFailedLoginAttemptsAsync(int userId);
    Task LockAccountAsync(int userId, TimeSpan lockoutDuration);
}
```

#### 3.3 Authentication Service
**File**: `src/Core/Services/AuthService.cs`
```csharp
public interface IAuthService
{
    Task<AuthResult> LoginAsync(LoginRequest request);
    Task<AuthResult> RegisterAsync(RegisterRequest request);
    Task<AuthResult> RefreshTokenAsync(RefreshTokenRequest request);
    Task<bool> LogoutAsync(int userId);
    Task<bool> ConfirmEmailAsync(string email, string token);
    Task<bool> RequestPasswordResetAsync(string email);
}

public class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordService _passwordService;
    private readonly IJwtService _jwtService;
    private readonly ILogger<AuthService> _logger;

    public async Task<AuthResult> LoginAsync(LoginRequest request)
    {
        var user = await _userRepository.GetByEmailAsync(request.Email);
        if (user == null)
        {
            return new AuthResult { Success = false, Error = "Invalid credentials" };
        }

        // Check account lockout
        if (user.AccountLockedUntil.HasValue && user.AccountLockedUntil > DateTime.UtcNow)
        {
            return new AuthResult { Success = false, Error = "Account temporarily locked" };
        }

        // Verify password
        if (!_passwordService.VerifyPassword(request.Password, user.PasswordHash))
        {
            await _userRepository.IncrementFailedLoginAttemptsAsync(user.Id);
            
            if (user.FailedLoginAttempts >= 4) // Lock after 5 attempts
            {
                await _userRepository.LockAccountAsync(user.Id, TimeSpan.FromMinutes(15));
            }
            
            return new AuthResult { Success = false, Error = "Invalid credentials" };
        }

        // Reset failed attempts and generate tokens
        await _userRepository.ResetFailedLoginAttemptsAsync(user.Id);
        
        var accessToken = _jwtService.GenerateAccessToken(user);
        var refreshToken = _jwtService.GenerateRefreshToken();
        
        await _userRepository.UpdateRefreshTokenAsync(user.Id, refreshToken, 
            DateTime.UtcNow.AddDays(7));

        return new AuthResult
        {
            Success = true,
            AccessToken = accessToken,
            RefreshToken = refreshToken,
            User = user
        };
    }
    
    // Additional methods...
}
```

### Task 4: API Controllers & DTOs (2 hours)

#### 4.1 Authentication DTOs
**File**: `src/Core/DTOs/AuthDtos.cs`
```csharp
public class LoginRequest
{
    [Required, EmailAddress]
    public string Email { get; set; } = null!;
    
    [Required, MinLength(6)]
    public string Password { get; set; } = null!;
}

public class RegisterRequest
{
    [Required, EmailAddress]
    public string Email { get; set; } = null!;
    
    [Required, MinLength(2)]
    public string FirstName { get; set; } = null!;
    
    [Required, MinLength(2)]
    public string LastName { get; set; } = null!;
    
    [Required, MinLength(8)]
    [RegularExpression(@"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]", 
        ErrorMessage = "Password must contain uppercase, lowercase, number and special character")]
    public string Password { get; set; } = null!;
}

public class RefreshTokenRequest
{
    [Required]
    public string AccessToken { get; set; } = null!;
    
    [Required]
    public string RefreshToken { get; set; } = null!;
}

public class AuthResponse
{
    public string AccessToken { get; set; } = null!;
    public string RefreshToken { get; set; } = null!;
    public DateTime ExpiresAt { get; set; }
    public UserDto User { get; set; } = null!;
}

public class UserDto
{
    public int Id { get; set; }
    public string Email { get; set; } = null!;
    public string FirstName { get; set; } = null!;
    public string LastName { get; set; } = null!;
    public string Role { get; set; } = null!;
    public bool IsEmailConfirmed { get; set; }
    public DateTime? LastLoginDate { get; set; }
}
```

#### 4.2 Updated Auth Controller
**File**: `src/Api/Controllers/AuthController.cs`
```csharp
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IAuthService _authService;
    private readonly ILogger<AuthController> _logger;

    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginRequest request)
    {
        var result = await _authService.LoginAsync(request);
        
        if (!result.Success)
        {
            return BadRequest(new { error = result.Error });
        }

        var response = new AuthResponse
        {
            AccessToken = result.AccessToken!,
            RefreshToken = result.RefreshToken!,
            ExpiresAt = DateTime.UtcNow.AddMinutes(60),
            User = new UserDto
            {
                Id = result.User!.Id,
                Email = result.User.Email,
                FirstName = result.User.FirstName,
                LastName = result.User.LastName,
                Role = result.User.Role.ToString(),
                IsEmailConfirmed = result.User.IsEmailConfirmed,
                LastLoginDate = result.User.LastLoginDate
            }
        };

        return Ok(response);
    }

    [HttpPost("register")]
    public async Task<IActionResult> Register([FromBody] RegisterRequest request)
    {
        var result = await _authService.RegisterAsync(request);
        
        if (!result.Success)
        {
            return BadRequest(new { error = result.Error });
        }

        return Ok(new { message = "Registration successful. Please check your email for verification." });
    }

    [HttpPost("refresh")]
    public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenRequest request)
    {
        var result = await _authService.RefreshTokenAsync(request);
        
        if (!result.Success)
        {
            return BadRequest(new { error = result.Error });
        }

        var response = new AuthResponse
        {
            AccessToken = result.AccessToken!,
            RefreshToken = result.RefreshToken!,
            ExpiresAt = DateTime.UtcNow.AddMinutes(60),
            User = new UserDto
            {
                Id = result.User!.Id,
                Email = result.User.Email,
                FirstName = result.User.FirstName,
                LastName = result.User.LastName,
                Role = result.User.Role.ToString(),
                IsEmailConfirmed = result.User.IsEmailConfirmed,
                LastLoginDate = result.User.LastLoginDate
            }
        };

        return Ok(response);
    }

    [HttpPost("logout")]
    [Authorize]
    public async Task<IActionResult> Logout()
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
        await _authService.LogoutAsync(userId);
        
        return Ok(new { message = "Logged out successfully" });
    }
}
```

### Task 5: Integration & Configuration (1 hour)

#### 5.1 JWT Middleware Configuration
**File**: `src/Api/Program.cs`
```csharp
// Add JWT Authentication
builder.Services.Configure<JwtSettings>(builder.Configuration.GetSection("JwtSettings"));

var jwtSettings = builder.Configuration.GetSection("JwtSettings").Get<JwtSettings>()!;

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = jwtSettings.Issuer,
            ValidAudience = jwtSettings.Audience,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings.SecretKey)),
            ClockSkew = TimeSpan.Zero
        };
    });

builder.Services.AddAuthorization();

// Register services
builder.Services.AddScoped<IJwtService, JwtService>();
builder.Services.AddScoped<IPasswordService, PasswordService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IUserRepository, UserRepository>();

// Add middleware
app.UseAuthentication();
app.UseAuthorization();
```

#### 5.2 Configuration Settings
**File**: `src/Api/appsettings.json`
```json
{
  "JwtSettings": {
    "SecretKey": "YourSuperSecretKeyThatShouldBeAt256BitsLong!",
    "Issuer": "DigitalMe.Api",
    "Audience": "DigitalMe.Client",
    "TokenExpiryMinutes": 60,
    "RefreshTokenExpiryDays": 7
  }
}
```

---

## âœ… VALIDATION & TESTING

### Security Testing Commands
```bash
# Test password hashing strength
dotnet test --filter "Category=PasswordSecurity"

# Test JWT token generation and validation
dotnet test --filter "Category=JwtSecurity"

# Test account lockout mechanism
dotnet test --filter "Category=AccountLockout"

# Test refresh token rotation
dotnet test --filter "Category=RefreshToken"
```

### Performance Validation
```bash
# Auth endpoint performance test
curl -X POST "http://localhost:5000/api/auth/login" \
     -H "Content-Type: application/json" \
     -d '{"email":"test@example.com","password":"TestPassword123!"}' \
     -w "@curl-format.txt"

# Should respond in <200ms
```

### Integration Checkpoints
- âœ… User registration with email validation
- âœ… Secure login with account lockout protection  
- âœ… JWT token generation with proper claims
- âœ… Refresh token rotation mechanism
- âœ… Role-based authorization middleware
- âœ… Audit trail integration with BaseEntity

---

## ðŸ”— INTEGRATION POINTS

### P2.1-P2.4 Compatibility Updates Required

#### PersonalityProfile.cs Enhancement
```csharp
public class PersonalityProfile : BaseEntity
{
    public int Id { get; set; }
    public int OwnerId { get; set; } // NEW: Link to User
    public User Owner { get; set; } = null!; // NEW: Navigation property
    public string Name { get; set; } = null!;
    // ... existing properties
}
```

#### ClaudeApiService.cs User Validation
```csharp
public class ClaudeApiService
{
    public async Task<string> GenerateResponseAsync(string prompt, int userId)
    {
        // NEW: Validate user before API call
        var user = await _userRepository.GetByIdAsync(userId);
        if (user == null || !user.IsActive)
        {
            throw new UnauthorizedAccessException("Invalid user");
        }
        
        // Existing API logic with user context
    }
}
```

### Next Component Integration
- **P3.1.2 API Security Hardening**: Will use User entity for rate limiting per user
- **P3.1.3 Production Monitoring**: Will use User context for audit trail enrichment
- **P3.1.4 Deployment Pipeline**: Will validate authentication in health checks

---

**COMPONENT SUMMARY**: P3.1.1 establishes secure JWT-based authentication foundation with user management, role-based access, and account protection. Seamlessly integrates with existing P2.1-P2.4 components while providing security context for subsequent P3.1 components.

**CRITICAL SUCCESS FACTORS**: BCrypt password hashing, JWT refresh rotation, account lockout protection, <200ms response time, comprehensive audit trail integration.