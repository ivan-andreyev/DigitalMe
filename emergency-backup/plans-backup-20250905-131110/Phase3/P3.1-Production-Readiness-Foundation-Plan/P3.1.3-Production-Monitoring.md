# P3.1.3 Production Monitoring

**Parent Plan**: [P3.1-Production-Readiness-Foundation-Plan.md](../P3.1-Production-Readiness-Foundation-Plan.md)  
**Timeline**: Week 3 (18 hours) | **Priority**: CRITICAL | **Dependencies**: P3.1.1 (for user context in metrics)

## ðŸŽ¯ COMPONENT MISSION

Implement comprehensive production monitoring with Application Insights integration, real-time dashboards, health checks, and intelligent alerting system for DigitalMe's production environment.

**Success Criteria**: Real-time visibility, <30s alert response time, 99.5%+ uptime tracking, comprehensive metrics

---

## ðŸ“Š CURRENT STATE ANALYSIS

### Existing P2.1-P2.4 Assets
âœ… **ClaudeApiService.cs** - Basic API service with health monitoring foundation  
âœ… **BaseEntity.cs** - Audit trail infrastructure ready for metrics  
âœ… **PostgreSQL Context** - Database performance metrics available  
âŒ **Application Insights** - Missing comprehensive telemetry  
âŒ **Health Checks** - No systematic health monitoring  
âŒ **Alerting System** - No automated incident response  
âŒ **Performance Dashboards** - No real-time visibility  

### Integration Requirements with P3.1.1 & P3.1.2
- **User Context**: Metrics enriched with user information from P3.1.1
- **Security Events**: Security incidents from P3.1.2 rate limiting and validation
- **Audit Trail Enhancement**: Comprehensive logging with user and security context
- **Performance Impact**: Monitor authentication and security overhead

---

## ðŸ”§ IMPLEMENTATION TASKS

### Task 1: Application Insights Integration (5 hours)

#### 1.1 Telemetry Configuration
**File**: `src/Infrastructure/Monitoring/TelemetrySettings.cs`
```csharp
public class TelemetrySettings
{
    public string InstrumentationKey { get; set; } = null!;
    public string ConnectionString { get; set; } = null!;
    public bool EnableAdaptiveSampling { get; set; } = true;
    public double SamplingPercentage { get; set; } = 100.0;
    public bool EnablePerformanceCounters { get; set; } = true;
    public bool EnableDependencyTracking { get; set; } = true;
    public TimeSpan FlushInterval { get; set; } = TimeSpan.FromSeconds(30);
}

public class CustomTelemetrySettings
{
    public Dictionary<string, string> GlobalProperties { get; set; } = new();
    public List<string> SensitiveDataFields { get; set; } = new()
    {
        "password", "token", "key", "secret", "authorization"
    };
}
```

#### 1.2 Custom Telemetry Service
**File**: `src/Infrastructure/Monitoring/TelemetryService.cs`
```csharp
public interface ITelemetryService
{
    void TrackEvent(string eventName, Dictionary<string, string>? properties = null, 
        Dictionary<string, double>? metrics = null);
    void TrackException(Exception exception, Dictionary<string, string>? properties = null);
    void TrackDependency(string dependencyType, string dependencyName, string data, 
        DateTime startTime, TimeSpan duration, bool success);
    void TrackMetric(string name, double value, Dictionary<string, string>? properties = null);
    void TrackRequest(string name, DateTime startTime, TimeSpan duration, 
        string responseCode, bool success);
    void TrackUserActivity(int userId, string activity, Dictionary<string, string>? properties = null);
    void TrackSecurityEvent(string eventType, string details, int? userId = null);
    void TrackPersonalityOperation(string operation, TimeSpan duration, bool success, 
        int userId, Dictionary<string, string>? properties = null);
}

public class TelemetryService : ITelemetryService
{
    private readonly TelemetryClient _telemetryClient;
    private readonly CustomTelemetrySettings _customSettings;
    private readonly ILogger<TelemetryService> _logger;
    private readonly IHttpContextAccessor _httpContextAccessor;

    public TelemetryService(TelemetryClient telemetryClient, 
        IOptions<CustomTelemetrySettings> customSettings,
        ILogger<TelemetryService> logger,
        IHttpContextAccessor httpContextAccessor)
    {
        _telemetryClient = telemetryClient;
        _customSettings = customSettings.Value;
        _logger = logger;
        _httpContextAccessor = httpContextAccessor;
    }

    public void TrackEvent(string eventName, Dictionary<string, string>? properties = null, 
        Dictionary<string, double>? metrics = null)
    {
        var enrichedProperties = EnrichProperties(properties);
        _telemetryClient.TrackEvent(eventName, enrichedProperties, metrics);
    }

    public void TrackUserActivity(int userId, string activity, 
        Dictionary<string, string>? properties = null)
    {
        var enrichedProperties = EnrichProperties(properties);
        enrichedProperties["UserId"] = userId.ToString();
        enrichedProperties["Activity"] = activity;
        enrichedProperties["Timestamp"] = DateTime.UtcNow.ToString("O");
        
        _telemetryClient.TrackEvent("UserActivity", enrichedProperties);
        
        // Also track as metric for aggregation
        TrackMetric("UserActivity.Count", 1, new Dictionary<string, string>
        {
            {"Activity", activity},
            {"UserId", userId.ToString()}
        });
    }

    public void TrackSecurityEvent(string eventType, string details, int? userId = null)
    {
        var properties = new Dictionary<string, string>
        {
            ["EventType"] = eventType,
            ["Details"] = SanitizeForLogging(details),
            ["Timestamp"] = DateTime.UtcNow.ToString("O"),
            ["Severity"] = GetSecurityEventSeverity(eventType),
            ["Source"] = "DigitalMe.Security"
        };

        if (userId.HasValue)
        {
            properties["UserId"] = userId.Value.ToString();
        }

        var enrichedProperties = EnrichProperties(properties);
        
        _telemetryClient.TrackEvent("SecurityEvent", enrichedProperties);
        
        // Track critical security events as exceptions for immediate alerting
        if (IsCriticalSecurityEvent(eventType))
        {
            var securityException = new SecurityException($"Critical security event: {eventType} - {details}");
            _telemetryClient.TrackException(securityException, enrichedProperties);
        }
    }

    public void TrackPersonalityOperation(string operation, TimeSpan duration, bool success, 
        int userId, Dictionary<string, string>? properties = null)
    {
        var enrichedProperties = EnrichProperties(properties);
        enrichedProperties["Operation"] = operation;
        enrichedProperties["UserId"] = userId.ToString();
        enrichedProperties["Success"] = success.ToString();
        enrichedProperties["Duration"] = duration.TotalMilliseconds.ToString("F2");

        _telemetryClient.TrackEvent("PersonalityOperation", enrichedProperties);
        
        // Track performance metrics
        TrackMetric($"PersonalityOperation.Duration.{operation}", duration.TotalMilliseconds);
        TrackMetric($"PersonalityOperation.Success.{operation}", success ? 1 : 0);
    }

    public void TrackDependency(string dependencyType, string dependencyName, string data, 
        DateTime startTime, TimeSpan duration, bool success)
    {
        var sanitizedData = SanitizeForLogging(data);
        _telemetryClient.TrackDependency(dependencyType, dependencyName, sanitizedData, 
            startTime, duration, success);
    }

    private Dictionary<string, string> EnrichProperties(Dictionary<string, string>? properties)
    {
        var enriched = new Dictionary<string, string>(properties ?? new Dictionary<string, string>());
        
        // Add global properties
        foreach (var globalProp in _customSettings.GlobalProperties)
        {
            enriched.TryAdd(globalProp.Key, globalProp.Value);
        }

        // Add HTTP context information
        var httpContext = _httpContextAccessor.HttpContext;
        if (httpContext != null)
        {
            enriched.TryAdd("RequestId", httpContext.TraceIdentifier);
            enriched.TryAdd("UserAgent", httpContext.Request.Headers.UserAgent.ToString());
            enriched.TryAdd("ClientIP", httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown");
            enriched.TryAdd("RequestPath", httpContext.Request.Path.Value ?? "");
            enriched.TryAdd("RequestMethod", httpContext.Request.Method);
            
            // Add user info if authenticated
            if (httpContext.User.Identity?.IsAuthenticated == true)
            {
                enriched.TryAdd("AuthenticatedUserId", 
                    httpContext.User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "");
                enriched.TryAdd("UserRole", 
                    httpContext.User.FindFirst(ClaimTypes.Role)?.Value ?? "");
            }
        }

        enriched.TryAdd("Environment", Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Unknown");
        enriched.TryAdd("MachineName", Environment.MachineName);
        enriched.TryAdd("Version", Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "Unknown");

        return enriched;
    }

    private string SanitizeForLogging(string data)
    {
        if (string.IsNullOrEmpty(data)) return data;

        var sanitized = data;
        foreach (var sensitiveField in _customSettings.SensitiveDataFields)
        {
            // Simple regex to redact sensitive data
            var pattern = $@"(""{sensitiveField}"":\s*""[^""]*"")";
            sanitized = Regex.Replace(sanitized, pattern, $@"""{sensitiveField}"":""[REDACTED]""", 
                RegexOptions.IgnoreCase);
        }

        // Truncate if too long
        return sanitized.Length > 1000 ? sanitized.Substring(0, 1000) + "..." : sanitized;
    }

    private string GetSecurityEventSeverity(string eventType) => eventType switch
    {
        "RateLimit" => "Medium",
        "SqlInjection" => "Critical",
        "XssScript" => "High",
        "CommandInjection" => "Critical",
        "PathTraversal" => "High",
        "UnauthorizedAccess" => "High",
        "AccountLockout" => "Medium",
        _ => "Low"
    };

    private bool IsCriticalSecurityEvent(string eventType) => eventType switch
    {
        "SqlInjection" => true,
        "CommandInjection" => true,
        "UnauthorizedAccess" => true,
        _ => false
    };
}
```

#### 1.3 Performance Monitoring Service
**File**: `src/Infrastructure/Monitoring/PerformanceMonitoringService.cs`
```csharp
public interface IPerformanceMonitoringService
{
    IDisposable BeginOperation(string operationName, Dictionary<string, string>? properties = null);
    void RecordDatabaseQuery(string queryType, TimeSpan duration, bool success, 
        string? tableName = null);
    void RecordApiCall(string apiName, TimeSpan duration, bool success, 
        int statusCode, string? userId = null);
    void RecordPersonalityGeneration(TimeSpan duration, bool success, string modelType, 
        int userId, int? profileId = null);
    Task<HealthCheckResult> GetSystemHealthAsync();
}

public class PerformanceMonitoringService : IPerformanceMonitoringService
{
    private readonly ITelemetryService _telemetryService;
    private readonly ILogger<PerformanceMonitoringService> _logger;
    private readonly IServiceProvider _serviceProvider;

    public IDisposable BeginOperation(string operationName, 
        Dictionary<string, string>? properties = null)
    {
        return new OperationScope(operationName, _telemetryService, properties);
    }

    public void RecordDatabaseQuery(string queryType, TimeSpan duration, bool success, 
        string? tableName = null)
    {
        var properties = new Dictionary<string, string>
        {
            ["QueryType"] = queryType,
            ["Success"] = success.ToString()
        };

        if (!string.IsNullOrEmpty(tableName))
        {
            properties["TableName"] = tableName;
        }

        _telemetryService.TrackMetric("Database.Query.Duration", duration.TotalMilliseconds, properties);
        _telemetryService.TrackMetric("Database.Query.Count", 1, properties);
        
        if (!success)
        {
            _telemetryService.TrackEvent("Database.Query.Failed", properties);
        }
    }

    public void RecordApiCall(string apiName, TimeSpan duration, bool success, 
        int statusCode, string? userId = null)
    {
        var properties = new Dictionary<string, string>
        {
            ["ApiName"] = apiName,
            ["StatusCode"] = statusCode.ToString(),
            ["Success"] = success.ToString()
        };

        if (!string.IsNullOrEmpty(userId))
        {
            properties["UserId"] = userId;
        }

        _telemetryService.TrackMetric("Api.Call.Duration", duration.TotalMilliseconds, properties);
        _telemetryService.TrackMetric("Api.Call.Count", 1, properties);
        
        if (statusCode >= 400)
        {
            _telemetryService.TrackEvent("Api.Call.Error", properties);
        }
    }

    public void RecordPersonalityGeneration(TimeSpan duration, bool success, string modelType, 
        int userId, int? profileId = null)
    {
        var properties = new Dictionary<string, string>
        {
            ["ModelType"] = modelType,
            ["Success"] = success.ToString(),
            ["UserId"] = userId.ToString()
        };

        if (profileId.HasValue)
        {
            properties["ProfileId"] = profileId.Value.ToString();
        }

        _telemetryService.TrackPersonalityOperation("PersonalityGeneration", duration, success, userId, properties);
        
        // Track specific metrics for personality generation performance
        _telemetryService.TrackMetric("Personality.Generation.Duration", duration.TotalMilliseconds, properties);
        
        if (duration.TotalSeconds > 10) // Alert if taking too long
        {
            _telemetryService.TrackEvent("Personality.Generation.SlowResponse", properties, 
                new Dictionary<string, double> { ["Duration"] = duration.TotalSeconds });
        }
    }

    public async Task<HealthCheckResult> GetSystemHealthAsync()
    {
        var healthChecks = new List<(string name, bool healthy, string? error)>();

        try
        {
            // Database health check
            using var scope = _serviceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
            await dbContext.Database.CanConnectAsync();
            healthChecks.Add(("Database", true, null));
        }
        catch (Exception ex)
        {
            healthChecks.Add(("Database", false, ex.Message));
        }

        // Add more health checks as needed...

        var overallHealthy = healthChecks.All(hc => hc.healthy);
        var result = new HealthCheckResult
        {
            IsHealthy = overallHealthy,
            Timestamp = DateTime.UtcNow,
            Checks = healthChecks.ToDictionary(hc => hc.name, hc => new HealthCheckDetail
            {
                IsHealthy = hc.healthy,
                Error = hc.error
            })
        };

        // Track health status
        _telemetryService.TrackMetric("System.Health.Overall", overallHealthy ? 1 : 0);
        
        return result;
    }
}

public class OperationScope : IDisposable
{
    private readonly string _operationName;
    private readonly ITelemetryService _telemetryService;
    private readonly Dictionary<string, string>? _properties;
    private readonly DateTime _startTime;
    private bool _disposed = false;

    public OperationScope(string operationName, ITelemetryService telemetryService, 
        Dictionary<string, string>? properties)
    {
        _operationName = operationName;
        _telemetryService = telemetryService;
        _properties = properties;
        _startTime = DateTime.UtcNow;
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            var duration = DateTime.UtcNow - _startTime;
            _telemetryService.TrackMetric($"Operation.{_operationName}.Duration", 
                duration.TotalMilliseconds, _properties);
            _telemetryService.TrackEvent($"Operation.{_operationName}.Completed", _properties);
            
            _disposed = true;
        }
    }
}

public class HealthCheckResult
{
    public bool IsHealthy { get; set; }
    public DateTime Timestamp { get; set; }
    public Dictionary<string, HealthCheckDetail> Checks { get; set; } = new();
}

public class HealthCheckDetail
{
    public bool IsHealthy { get; set; }
    public string? Error { get; set; }
}
```

### Task 2: Health Checks System (4 hours)

#### 2.1 Custom Health Checks
**File**: `src/Infrastructure/HealthChecks/DatabaseHealthCheck.cs`
```csharp
public class DatabaseHealthCheck : IHealthCheck
{
    private readonly ApplicationDbContext _dbContext;
    private readonly ILogger<DatabaseHealthCheck> _logger;

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, 
        CancellationToken cancellationToken = default)
    {
        try
        {
            // Test database connection
            await _dbContext.Database.CanConnectAsync(cancellationToken);
            
            // Test a simple query
            var userCount = await _dbContext.Users.CountAsync(cancellationToken);
            
            // Check for recent data activity
            var recentActivity = await _dbContext.Users
                .Where(u => u.LastLoginDate > DateTime.UtcNow.AddHours(-24))
                .CountAsync(cancellationToken);

            var data = new Dictionary<string, object>
            {
                ["TotalUsers"] = userCount,
                ["ActiveUsersLast24Hours"] = recentActivity,
                ["DatabaseProvider"] = _dbContext.Database.ProviderName ?? "Unknown",
                ["CheckTimestamp"] = DateTime.UtcNow
            };

            return HealthCheckResult.Healthy("Database is healthy", data);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Database health check failed");
            return HealthCheckResult.Unhealthy("Database connection failed", ex, 
                new Dictionary<string, object> { ["Error"] = ex.Message });
        }
    }
}

public class RedisHealthCheck : IHealthCheck
{
    private readonly IConnectionMultiplexer _redis;
    private readonly ILogger<RedisHealthCheck> _logger;

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, 
        CancellationToken cancellationToken = default)
    {
        try
        {
            var database = _redis.GetDatabase();
            var key = "health_check_" + Guid.NewGuid();
            var value = DateTime.UtcNow.Ticks.ToString();

            // Test write
            await database.StringSetAsync(key, value, TimeSpan.FromSeconds(30));
            
            // Test read
            var retrievedValue = await database.StringGetAsync(key);
            
            // Clean up
            await database.KeyDeleteAsync(key);

            if (retrievedValue == value)
            {
                var info = _redis.GetServer(_redis.GetEndPoints().First()).Info("memory");
                var usedMemory = info.FirstOrDefault(i => i.Key == "used_memory")?.Value ?? "Unknown";
                
                return HealthCheckResult.Healthy("Redis is healthy", new Dictionary<string, object>
                {
                    ["UsedMemory"] = usedMemory,
                    ["IsConnected"] = _redis.IsConnected,
                    ["CheckTimestamp"] = DateTime.UtcNow
                });
            }

            return HealthCheckResult.Unhealthy("Redis read/write test failed");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Redis health check failed");
            return HealthCheckResult.Unhealthy("Redis connection failed", ex);
        }
    }
}

public class ClaudeApiHealthCheck : IHealthCheck
{
    private readonly IClaudeApiService _claudeApiService;
    private readonly ILogger<ClaudeApiHealthCheck> _logger;

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, 
        CancellationToken cancellationToken = default)
    {
        try
        {
            // Simple health check call to Claude API
            var startTime = DateTime.UtcNow;
            var testPrompt = "Health check test - please respond with 'OK'";
            
            var response = await _claudeApiService.GenerateResponseAsync(testPrompt, userId: 0);
            var duration = DateTime.UtcNow - startTime;

            var isHealthy = !string.IsNullOrEmpty(response) && duration.TotalSeconds < 10;
            var status = isHealthy ? "Healthy" : "Degraded";

            var data = new Dictionary<string, object>
            {
                ["ResponseTime"] = duration.TotalMilliseconds,
                ["Status"] = status,
                ["CheckTimestamp"] = DateTime.UtcNow
            };

            return isHealthy 
                ? HealthCheckResult.Healthy($"Claude API is {status.ToLower()}", data)
                : HealthCheckResult.Degraded($"Claude API is {status.ToLower()}", data);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Claude API health check failed");
            return HealthCheckResult.Unhealthy("Claude API connection failed", ex);
        }
    }
}
```

#### 2.2 Health Check Configuration
**File**: `src/Api/Configuration/HealthCheckConfiguration.cs`
```csharp
public static class HealthCheckConfiguration
{
    public static void ConfigureHealthChecks(this IServiceCollection services, 
        IConfiguration configuration)
    {
        services.AddHealthChecks()
            .AddCheck<DatabaseHealthCheck>("database", 
                failureStatus: HealthStatus.Unhealthy,
                timeout: TimeSpan.FromSeconds(30))
            .AddCheck<RedisHealthCheck>("redis", 
                failureStatus: HealthStatus.Degraded,
                timeout: TimeSpan.FromSeconds(15))
            .AddCheck<ClaudeApiHealthCheck>("claude-api", 
                failureStatus: HealthStatus.Degraded,
                timeout: TimeSpan.FromSeconds(20))
            .AddApplicationInsightsPublisher()
            .AddConsolePublisher();

        // Configure health check UI (optional, for development)
        services.AddHealthChecksUI(options =>
        {
            options.SetEvaluationTimeInSeconds(30);
            options.AddHealthCheckEndpoint("DigitalMe API", "/health");
        }).AddInMemoryStorage();
    }

    public static void UseHealthChecks(this IApplicationBuilder app)
    {
        app.UseHealthChecks("/health", new HealthCheckOptions
        {
            ResponseWriter = WriteHealthCheckResponse,
            ResultStatusCodes =
            {
                [HealthStatus.Healthy] = StatusCodes.Status200OK,
                [HealthStatus.Degraded] = StatusCodes.Status200OK,
                [HealthStatus.Unhealthy] = StatusCodes.Status503ServiceUnavailable
            }
        });

        app.UseHealthChecks("/health/ready", new HealthCheckOptions
        {
            Predicate = check => check.Name != "claude-api", // Exclude external dependencies
            ResponseWriter = WriteHealthCheckResponse
        });

        app.UseHealthChecks("/health/live", new HealthCheckOptions
        {
            Predicate = _ => false, // No checks, just return that the app is running
            ResponseWriter = (context, result) =>
            {
                context.Response.ContentType = "application/json";
                return context.Response.WriteAsync(JsonSerializer.Serialize(new
                {
                    status = "UP",
                    timestamp = DateTime.UtcNow
                }));
            }
        });
    }

    private static async Task WriteHealthCheckResponse(HttpContext context, HealthReport result)
    {
        context.Response.ContentType = "application/json";

        var response = new
        {
            status = result.Status.ToString(),
            totalDuration = result.TotalDuration.TotalMilliseconds,
            timestamp = DateTime.UtcNow,
            results = result.Entries.Select(pair => new
            {
                name = pair.Key,
                status = pair.Value.Status.ToString(),
                duration = pair.Value.Duration.TotalMilliseconds,
                description = pair.Value.Description,
                data = pair.Value.Data,
                exception = pair.Value.Exception?.Message
            })
        };

        await context.Response.WriteAsync(JsonSerializer.Serialize(response, new JsonSerializerOptions
        {
            WriteIndented = true
        }));
    }
}
```

### Task 3: Alert System & Notifications (4 hours)

#### 3.1 Alert Service Interface
**File**: `src/Core/Services/AlertService.cs`
```csharp
public interface IAlertService
{
    Task SendAlertAsync(Alert alert);
    Task<List<Alert>> GetActiveAlertsAsync();
    Task ResolveAlertAsync(string alertId, string resolvedBy);
    Task ConfigureAlertRuleAsync(AlertRule rule);
}

public class Alert
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Title { get; set; } = null!;
    public string Description { get; set; } = null!;
    public AlertSeverity Severity { get; set; }
    public AlertCategory Category { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime? ResolvedAt { get; set; }
    public string? ResolvedBy { get; set; }
    public Dictionary<string, object> Properties { get; set; } = new();
    public List<string> AffectedComponents { get; set; } = new();
}

public enum AlertSeverity
{
    Low = 1,
    Medium = 2,
    High = 3,
    Critical = 4
}

public enum AlertCategory
{
    Performance,
    Security,
    Availability,
    Error,
    Business
}

public class AlertRule
{
    public string Id { get; set; } = null!;
    public string Name { get; set; } = null!;
    public string Description { get; set; } = null!;
    public string MetricName { get; set; } = null!;
    public AlertCondition Condition { get; set; } = null!;
    public double Threshold { get; set; }
    public TimeSpan EvaluationWindow { get; set; }
    public AlertSeverity Severity { get; set; }
    public List<string> NotificationChannels { get; set; } = new();
    public bool IsEnabled { get; set; } = true;
}

public class AlertCondition
{
    public ComparisonOperator Operator { get; set; }
    public int MinDataPoints { get; set; } = 1;
    public TimeSpan MinDuration { get; set; } = TimeSpan.FromMinutes(1);
}

public enum ComparisonOperator
{
    GreaterThan,
    LessThan,
    Equals,
    NotEquals
}

public class AlertService : IAlertService
{
    private readonly ITelemetryService _telemetryService;
    private readonly INotificationService _notificationService;
    private readonly ILogger<AlertService> _logger;
    private readonly List<Alert> _activeAlerts = new(); // In production, use persistent storage

    public async Task SendAlertAsync(Alert alert)
    {
        _activeAlerts.Add(alert);
        
        // Track the alert
        _telemetryService.TrackEvent("Alert.Triggered", new Dictionary<string, string>
        {
            ["AlertId"] = alert.Id,
            ["Title"] = alert.Title,
            ["Severity"] = alert.Severity.ToString(),
            ["Category"] = alert.Category.ToString()
        });

        // Send notifications based on severity
        switch (alert.Severity)
        {
            case AlertSeverity.Critical:
                await _notificationService.SendCriticalAlertAsync(alert);
                break;
            case AlertSeverity.High:
                await _notificationService.SendHighPriorityAlertAsync(alert);
                break;
            default:
                await _notificationService.SendStandardAlertAsync(alert);
                break;
        }

        _logger.LogWarning("Alert triggered: {Title} - {Description} (Severity: {Severity})",
            alert.Title, alert.Description, alert.Severity);
    }

    public Task<List<Alert>> GetActiveAlertsAsync()
    {
        return Task.FromResult(_activeAlerts.Where(a => !a.ResolvedAt.HasValue).ToList());
    }

    public async Task ResolveAlertAsync(string alertId, string resolvedBy)
    {
        var alert = _activeAlerts.FirstOrDefault(a => a.Id == alertId);
        if (alert != null)
        {
            alert.ResolvedAt = DateTime.UtcNow;
            alert.ResolvedBy = resolvedBy;

            _telemetryService.TrackEvent("Alert.Resolved", new Dictionary<string, string>
            {
                ["AlertId"] = alertId,
                ["ResolvedBy"] = resolvedBy,
                ["Duration"] = (alert.ResolvedAt.Value - alert.CreatedAt).TotalMinutes.ToString("F1")
            });

            await _notificationService.SendAlertResolvedAsync(alert);
        }
    }
}
```

#### 3.2 Notification Service
**File**: `src/Infrastructure/Notifications/NotificationService.cs`
```csharp
public interface INotificationService
{
    Task SendCriticalAlertAsync(Alert alert);
    Task SendHighPriorityAlertAsync(Alert alert);
    Task SendStandardAlertAsync(Alert alert);
    Task SendAlertResolvedAsync(Alert alert);
}

public class NotificationService : INotificationService
{
    private readonly ILogger<NotificationService> _logger;
    private readonly NotificationSettings _settings;

    public async Task SendCriticalAlertAsync(Alert alert)
    {
        // For critical alerts, send via multiple channels
        await SendEmailNotificationAsync(alert);
        await SendSlackNotificationAsync(alert);
        await SendSmsNotificationAsync(alert); // If configured
        
        _logger.LogCritical("Critical alert sent: {Title}", alert.Title);
    }

    public async Task SendHighPriorityAlertAsync(Alert alert)
    {
        await SendEmailNotificationAsync(alert);
        await SendSlackNotificationAsync(alert);
        
        _logger.LogWarning("High priority alert sent: {Title}", alert.Title);
    }

    public async Task SendStandardAlertAsync(Alert alert)
    {
        await SendSlackNotificationAsync(alert);
        
        _logger.LogInformation("Standard alert sent: {Title}", alert.Title);
    }

    public async Task SendAlertResolvedAsync(Alert alert)
    {
        await SendSlackNotificationAsync(alert, isResolved: true);
        
        _logger.LogInformation("Alert resolved notification sent: {Title}", alert.Title);
    }

    private async Task SendEmailNotificationAsync(Alert alert)
    {
        // Email notification implementation
        // Use SendGrid, Azure Communication Services, or similar
        await Task.Delay(100); // Placeholder
    }

    private async Task SendSlackNotificationAsync(Alert alert, bool isResolved = false)
    {
        // Slack notification implementation
        var color = isResolved ? "good" : alert.Severity switch
        {
            AlertSeverity.Critical => "danger",
            AlertSeverity.High => "warning",
            _ => "#ffaa00"
        };

        var message = new
        {
            text = isResolved ? $"ðŸŸ¢ Alert Resolved: {alert.Title}" : $"ðŸš¨ Alert: {alert.Title}",
            attachments = new[]
            {
                new
                {
                    color = color,
                    fields = new[]
                    {
                        new { title = "Description", value = alert.Description, @short = false },
                        new { title = "Severity", value = alert.Severity.ToString(), @short = true },
                        new { title = "Category", value = alert.Category.ToString(), @short = true },
                        new { title = "Time", value = alert.CreatedAt.ToString("yyyy-MM-dd HH:mm:ss UTC"), @short = true }
                    }
                }
            }
        };

        // Send to Slack webhook (implementation depends on your setup)
        await Task.Delay(100); // Placeholder
    }

    private async Task SendSmsNotificationAsync(Alert alert)
    {
        // SMS notification for critical alerts only
        if (alert.Severity == AlertSeverity.Critical)
        {
            // Implementation using Twilio, Azure Communication Services, etc.
            await Task.Delay(100); // Placeholder
        }
    }
}

public class NotificationSettings
{
    public EmailSettings Email { get; set; } = new();
    public SlackSettings Slack { get; set; } = new();
    public SmsSettings Sms { get; set; } = new();
}

public class EmailSettings
{
    public string SmtpServer { get; set; } = null!;
    public int SmtpPort { get; set; } = 587;
    public string Username { get; set; } = null!;
    public string Password { get; set; } = null!;
    public List<string> CriticalAlertRecipients { get; set; } = new();
    public List<string> StandardAlertRecipients { get; set; } = new();
}

public class SlackSettings
{
    public string WebhookUrl { get; set; } = null!;
    public string Channel { get; set; } = "#alerts";
    public bool Enabled { get; set; } = true;
}

public class SmsSettings
{
    public string AccountSid { get; set; } = null!;
    public string AuthToken { get; set; } = null!;
    public string FromNumber { get; set; } = null!;
    public List<string> CriticalAlertRecipients { get; set; } = new();
    public bool Enabled { get; set; } = false;
}
```

### Task 4: Real-time Dashboards & Metrics (3 hours)

#### 4.1 Metrics Controller
**File**: `src/Api/Controllers/MetricsController.cs`
```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize(Roles = "Admin,SuperAdmin")]
public class MetricsController : ControllerBase
{
    private readonly ITelemetryService _telemetryService;
    private readonly IPerformanceMonitoringService _performanceService;
    private readonly IAlertService _alertService;
    private readonly ILogger<MetricsController> _logger;

    [HttpGet("dashboard")]
    public async Task<IActionResult> GetDashboardMetrics([FromQuery] TimeSpan? timeWindow = null)
    {
        var window = timeWindow ?? TimeSpan.FromHours(1);
        var endTime = DateTime.UtcNow;
        var startTime = endTime.Subtract(window);

        var metrics = new
        {
            TimeWindow = new { Start = startTime, End = endTime },
            System = await GetSystemMetricsAsync(startTime, endTime),
            Performance = await GetPerformanceMetricsAsync(startTime, endTime),
            Security = await GetSecurityMetricsAsync(startTime, endTime),
            Business = await GetBusinessMetricsAsync(startTime, endTime),
            Health = await _performanceService.GetSystemHealthAsync(),
            ActiveAlerts = await _alertService.GetActiveAlertsAsync()
        };

        return Ok(metrics);
    }

    [HttpGet("performance")]
    public async Task<IActionResult> GetPerformanceMetrics([FromQuery] DateTime? start = null, 
        [FromQuery] DateTime? end = null)
    {
        var startTime = start ?? DateTime.UtcNow.AddHours(-1);
        var endTime = end ?? DateTime.UtcNow;

        var metrics = await GetPerformanceMetricsAsync(startTime, endTime);
        return Ok(metrics);
    }

    [HttpGet("security")]
    public async Task<IActionResult> GetSecurityMetrics([FromQuery] DateTime? start = null, 
        [FromQuery] DateTime? end = null)
    {
        var startTime = start ?? DateTime.UtcNow.AddHours(-1);
        var endTime = end ?? DateTime.UtcNow;

        var metrics = await GetSecurityMetricsAsync(startTime, endTime);
        return Ok(metrics);
    }

    private async Task<object> GetSystemMetricsAsync(DateTime start, DateTime end)
    {
        // In a real implementation, these would query Application Insights or your metrics store
        return new
        {
            Uptime = DateTime.UtcNow - Process.GetCurrentProcess().StartTime.ToUniversalTime(),
            MemoryUsage = new
            {
                WorkingSet = GC.GetTotalMemory(false),
                Gen0Collections = GC.CollectionCount(0),
                Gen1Collections = GC.CollectionCount(1),
                Gen2Collections = GC.CollectionCount(2)
            },
            ThreadCount = Process.GetCurrentProcess().Threads.Count,
            HandleCount = Process.GetCurrentProcess().HandleCount
        };
    }

    private async Task<object> GetPerformanceMetricsAsync(DateTime start, DateTime end)
    {
        // Mock implementation - in production, query Application Insights
        return new
        {
            RequestsPerMinute = new { Current = 45, Average = 52, Peak = 125 },
            ResponseTimes = new
            {
                Average = 156, // ms
                P50 = 134,
                P95 = 287,
                P99 = 456
            },
            PersonalityGeneration = new
            {
                AverageTime = 2.3, // seconds
                SuccessRate = 99.2, // percentage
                RequestsPerHour = 234
            },
            DatabaseQueries = new
            {
                AverageTime = 45, // ms
                SlowQueries = 3,
                ConnectionPoolUsage = 15 // out of 100
            }
        };
    }

    private async Task<object> GetSecurityMetricsAsync(DateTime start, DateTime end)
    {
        return new
        {
            RateLimitViolations = new { Count = 12, UniqueIPs = 3 },
            ThreatDetections = new
            {
                SqlInjection = 0,
                XssAttempts = 2,
                SuspiciousActivity = 5
            },
            AuthenticationEvents = new
            {
                SuccessfulLogins = 45,
                FailedLogins = 8,
                AccountLockouts = 1
            },
            ApiKeyUsage = new
            {
                ActiveKeys = 15,
                RequestsViaApiKey = 1234,
                InvalidKeyAttempts = 7
            }
        };
    }

    private async Task<object> GetBusinessMetricsAsync(DateTime start, DateTime end)
    {
        return new
        {
            ActiveUsers = new { Current = 23, Peak = 67, Total = 156 },
            PersonalityProfiles = new
            {
                Created = 8,
                Updated = 15,
                Queries = 234
            },
            Conversations = new
            {
                Started = 45,
                Completed = 38,
                AverageLength = 12.5 // messages
            },
            TelegramIntegration = new
            {
                Messages = 89,
                UniqueChats = 23,
                Errors = 2
            }
        };
    }
}
```

#### 4.2 Real-time Metrics Hub (SignalR)
**File**: `src/Api/Hubs/MetricsHub.cs`
```csharp
public class MetricsHub : Hub
{
    private readonly ILogger<MetricsHub> _logger;

    public async Task JoinGroup(string groupName)
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, groupName);
        _logger.LogInformation("Client {ConnectionId} joined group {GroupName}", 
            Context.ConnectionId, groupName);
    }

    public async Task LeaveGroup(string groupName)
    {
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName);
        _logger.LogInformation("Client {ConnectionId} left group {GroupName}", 
            Context.ConnectionId, groupName);
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        _logger.LogInformation("Client {ConnectionId} disconnected", Context.ConnectionId);
        await base.OnDisconnectedAsync(exception);
    }
}

public class MetricsBroadcastService : BackgroundService
{
    private readonly IHubContext<MetricsHub> _hubContext;
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<MetricsBroadcastService> _logger;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var performanceService = scope.ServiceProvider
                    .GetRequiredService<IPerformanceMonitoringService>();

                var healthStatus = await performanceService.GetSystemHealthAsync();
                
                await _hubContext.Clients.Group("dashboard").SendAsync("HealthUpdate", 
                    healthStatus, stoppingToken);

                // Send real-time metrics every 30 seconds
                await Task.Delay(30000, stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in metrics broadcast service");
                await Task.Delay(5000, stoppingToken);
            }
        }
    }
}
```

### Task 5: Configuration & Integration (2 hours)

#### 5.1 Application Insights Configuration
**File**: `src/Api/Program.cs` (additions)
```csharp
// Application Insights configuration
builder.Services.AddApplicationInsightsTelemetry(options =>
{
    options.ConnectionString = builder.Configuration.GetConnectionString("ApplicationInsights");
    options.EnableAdaptiveSampling = true;
    options.EnablePerformanceCounterCollectionModule = true;
    options.EnableDependencyTrackingTelemetryModule = true;
});

// Custom telemetry services
builder.Services.Configure<TelemetrySettings>(
    builder.Configuration.GetSection("TelemetrySettings"));
builder.Services.Configure<CustomTelemetrySettings>(
    builder.Configuration.GetSection("CustomTelemetrySettings"));

builder.Services.AddSingleton<ITelemetryService, TelemetryService>();
builder.Services.AddScoped<IPerformanceMonitoringService, PerformanceMonitoringService>();
builder.Services.AddSingleton<IAlertService, AlertService>();
builder.Services.AddSingleton<INotificationService, NotificationService>();

// Health checks
builder.Services.ConfigureHealthChecks(builder.Configuration);

// SignalR for real-time metrics
builder.Services.AddSignalR();
builder.Services.AddHostedService<MetricsBroadcastService>();

// Configure the app
var app = builder.Build();

// Use health checks
app.UseHealthChecks();

// SignalR hub
app.MapHub<MetricsHub>("/hubs/metrics");
```

#### 5.2 Configuration Settings
**File**: `src/Api/appsettings.json` (additions)
```json
{
  "ConnectionStrings": {
    "ApplicationInsights": "InstrumentationKey=your-key-here;IngestionEndpoint=https://...",
    "Redis": "localhost:6379"
  },
  "TelemetrySettings": {
    "EnableAdaptiveSampling": true,
    "SamplingPercentage": 100.0,
    "EnablePerformanceCounters": true,
    "EnableDependencyTracking": true,
    "FlushInterval": "00:00:30"
  },
  "CustomTelemetrySettings": {
    "GlobalProperties": {
      "Environment": "Production",
      "Application": "DigitalMe",
      "Version": "3.1.0"
    },
    "SensitiveDataFields": [
      "password", "token", "key", "secret", "authorization", "apikey"
    ]
  },
  "NotificationSettings": {
    "Slack": {
      "WebhookUrl": "https://hooks.slack.com/services/...",
      "Channel": "#digitalme-alerts",
      "Enabled": true
    },
    "Email": {
      "SmtpServer": "smtp.gmail.com",
      "SmtpPort": 587,
      "CriticalAlertRecipients": ["admin@digitalme.com"],
      "StandardAlertRecipients": ["team@digitalme.com"]
    }
  }
}
```

---

## âœ… VALIDATION & TESTING

### Monitoring Testing Commands
```bash
# Test health endpoints
curl http://localhost:5000/health
curl http://localhost:5000/health/ready
curl http://localhost:5000/health/live

# Test metrics endpoint (requires admin auth)
curl -H "Authorization: Bearer <admin-jwt>" \
     http://localhost:5000/api/metrics/dashboard

# Test Application Insights integration
curl -X POST http://localhost:5000/api/personality \
     -H "Content-Type: application/json" \
     -d '{"name":"Test","data":{"test":"value"}}'

# Verify telemetry in Application Insights portal
```

### Alert Testing
```bash
# Trigger rate limit alert
for i in {1..200}; do curl http://localhost:5000/api/personality & done

# Trigger performance alert (simulate slow response)
curl -X POST http://localhost:5000/test/slow-endpoint

# Test critical security alert
curl -X POST http://localhost:5000/api/personality \
     -d '{"name":"<script>alert(\"xss\")</script>"}'
```

---

## ðŸ”— INTEGRATION POINTS

### P3.1.1 & P3.1.2 Integration
- **User Context**: All metrics enriched with user information from JWT
- **Security Events**: Rate limit violations and threat detections tracked
- **Authentication Metrics**: Login success/failure rates, account lockouts
- **Performance Impact**: Monitor auth and security validation overhead

### P3.1.4 Deployment Pipeline Integration
- **Health Checks**: Used in deployment readiness validation
- **Metrics Collection**: Performance baselines for deployment decisions
- **Alert Integration**: Deployment notifications and rollback triggers
- **Environment Monitoring**: Staging vs production metrics comparison

### P3.1.5 Integration Testing Preparation
- **Test Data**: Metrics and alerts generated during testing
- **Performance Baselines**: Established benchmarks for test validation
- **Monitoring Coverage**: Comprehensive coverage validation

---

**COMPONENT SUMMARY**: P3.1.3 provides comprehensive production monitoring with Application Insights, health checks, intelligent alerting, and real-time dashboards. Enables proactive system management with <30s alert response times and 99.5%+ uptime tracking.

**CRITICAL SUCCESS FACTORS**: Real-time visibility, comprehensive metrics collection, intelligent alerting, seamless integration with security and authentication systems, automated incident response capabilities.