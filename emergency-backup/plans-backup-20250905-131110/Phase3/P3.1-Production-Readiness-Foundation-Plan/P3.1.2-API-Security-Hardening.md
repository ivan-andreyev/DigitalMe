# P3.1.2 API Security Hardening

**Parent Plan**: [P3.1-Production-Readiness-Foundation-Plan.md](../P3.1-Production-Readiness-Foundation-Plan.md)  
**Timeline**: Week 1-2 parallel (19 hours) | **Priority**: CRITICAL | **Dependencies**: P3.1.1 (for user-based rate limiting)

## üéØ COMPONENT MISSION

Implement comprehensive API security hardening including Redis-based rate limiting, input validation, API key management, and attack prevention to protect DigitalMe's production endpoints.

**Success Criteria**: Zero critical vulnerabilities, rate limiting enforcement, comprehensive input validation

---

## üìä CURRENT STATE ANALYSIS

### Existing P2.1-P2.4 Assets
‚úÖ **ClaudeApiService.cs** - Basic API service with rate limiting foundation  
‚úÖ **Controllers** - Auth, Personality, Conversation, Telegram endpoints  
‚úÖ **PostgreSQL Context** - Database foundation ready  
‚ùå **Redis Rate Limiting** - Missing distributed rate limiting  
‚ùå **Input Validation** - Basic validation, needs hardening  
‚ùå **Security Headers** - Missing comprehensive security middleware  
‚ùå **API Key Management** - No API key authentication system  

### Integration Requirements with P3.1.1
- **User-Based Rate Limiting**: Different limits for authenticated vs anonymous users
- **Role-Based API Access**: Admin endpoints with elevated security
- **Audit Trail Integration**: Security events logged with user context
- **JWT Token Validation**: All secured endpoints require valid authentication

---

## üîß IMPLEMENTATION TASKS

### Task 1: Redis-Based Rate Limiting (6 hours)

#### 1.1 Redis Configuration Setup
**File**: `src/Infrastructure/Caching/RedisCacheSettings.cs`
```csharp
public class RedisCacheSettings
{
    public string ConnectionString { get; set; } = null!;
    public int Database { get; set; } = 0;
    public TimeSpan DefaultExpiry { get; set; } = TimeSpan.FromHours(1);
    public string KeyPrefix { get; set; } = "DigitalMe:";
}

public class RateLimitSettings
{
    public Dictionary<string, RateLimitRule> Rules { get; set; } = new();
}

public class RateLimitRule
{
    public int RequestsPerMinute { get; set; }
    public int RequestsPerHour { get; set; }
    public int RequestsPerDay { get; set; }
    public TimeSpan BlockDuration { get; set; } = TimeSpan.FromMinutes(15);
    public string[]? Endpoints { get; set; }
    public string[]? UserRoles { get; set; }
}
```

#### 1.2 Rate Limiting Service Interface
**File**: `src/Core/Interfaces/IRateLimitService.cs`
```csharp
public interface IRateLimitService
{
    Task<RateLimitResult> CheckRateLimitAsync(string identifier, string endpoint, 
        string? userRole = null, int? userId = null);
    Task ResetRateLimitAsync(string identifier, string endpoint);
    Task<Dictionary<string, RateLimitStatus>> GetRateLimitStatusAsync(string identifier);
}

public class RateLimitResult
{
    public bool IsAllowed { get; set; }
    public int RequestsRemaining { get; set; }
    public DateTime WindowResetTime { get; set; }
    public string? BlockedReason { get; set; }
    public TimeSpan? RetryAfter { get; set; }
}

public class RateLimitStatus
{
    public int RequestsInMinute { get; set; }
    public int RequestsInHour { get; set; }
    public int RequestsInDay { get; set; }
    public DateTime WindowResetTime { get; set; }
}
```

#### 1.3 Redis Rate Limiting Implementation
**File**: `src/Infrastructure/Caching/RedisRateLimitService.cs`
```csharp
public class RedisRateLimitService : IRateLimitService
{
    private readonly IDatabase _database;
    private readonly RateLimitSettings _rateLimitSettings;
    private readonly ILogger<RedisRateLimitService> _logger;

    public async Task<RateLimitResult> CheckRateLimitAsync(string identifier, string endpoint, 
        string? userRole = null, int? userId = null)
    {
        var rule = GetApplicableRule(endpoint, userRole);
        var keyBase = $"rate_limit:{identifier}:{endpoint}";
        
        var pipeline = _database.CreateBatch();
        
        // Check minute, hour, and day limits
        var minuteKey = $"{keyBase}:minute:{DateTime.UtcNow:yyyy-MM-dd-HH-mm}";
        var hourKey = $"{keyBase}:hour:{DateTime.UtcNow:yyyy-MM-dd-HH}";
        var dayKey = $"{keyBase}:day:{DateTime.UtcNow:yyyy-MM-dd}";

        var minuteCountTask = pipeline.StringIncrementAsync(minuteKey);
        var hourCountTask = pipeline.StringIncrementAsync(hourKey);
        var dayCountTask = pipeline.StringIncrementAsync(dayKey);

        // Set expiry for keys
        pipeline.KeyExpireAsync(minuteKey, TimeSpan.FromMinutes(1));
        pipeline.KeyExpireAsync(hourKey, TimeSpan.FromHours(1));
        pipeline.KeyExpireAsync(dayKey, TimeSpan.FromDays(1));

        pipeline.Execute();

        var minuteCount = await minuteCountTask;
        var hourCount = await hourCountTask;
        var dayCount = await dayCountTask;

        // Check limits
        if (minuteCount > rule.RequestsPerMinute)
        {
            await LogSecurityEventAsync("RateLimit", identifier, endpoint, 
                $"Minute limit exceeded: {minuteCount}/{rule.RequestsPerMinute}", userId);
            
            return new RateLimitResult
            {
                IsAllowed = false,
                RequestsRemaining = 0,
                WindowResetTime = DateTime.UtcNow.AddMinutes(1).AddSeconds(-DateTime.UtcNow.Second),
                BlockedReason = "Minute rate limit exceeded",
                RetryAfter = TimeSpan.FromSeconds(60 - DateTime.UtcNow.Second)
            };
        }

        if (hourCount > rule.RequestsPerHour)
        {
            await LogSecurityEventAsync("RateLimit", identifier, endpoint, 
                $"Hour limit exceeded: {hourCount}/{rule.RequestsPerHour}", userId);
            
            return new RateLimitResult
            {
                IsAllowed = false,
                RequestsRemaining = 0,
                WindowResetTime = DateTime.UtcNow.AddHours(1).AddMinutes(-DateTime.UtcNow.Minute),
                BlockedReason = "Hourly rate limit exceeded",
                RetryAfter = TimeSpan.FromMinutes(60 - DateTime.UtcNow.Minute)
            };
        }

        if (dayCount > rule.RequestsPerDay)
        {
            await LogSecurityEventAsync("RateLimit", identifier, endpoint, 
                $"Day limit exceeded: {dayCount}/{rule.RequestsPerDay}", userId);
            
            return new RateLimitResult
            {
                IsAllowed = false,
                RequestsRemaining = 0,
                WindowResetTime = DateTime.UtcNow.AddDays(1).Date,
                BlockedReason = "Daily rate limit exceeded",
                RetryAfter = DateTime.UtcNow.AddDays(1).Date - DateTime.UtcNow
            };
        }

        return new RateLimitResult
        {
            IsAllowed = true,
            RequestsRemaining = Math.Min(
                rule.RequestsPerMinute - (int)minuteCount,
                Math.Min(rule.RequestsPerHour - (int)hourCount, rule.RequestsPerDay - (int)dayCount)),
            WindowResetTime = DateTime.UtcNow.AddMinutes(1).AddSeconds(-DateTime.UtcNow.Second)
        };
    }

    private RateLimitRule GetApplicableRule(string endpoint, string? userRole)
    {
        // Default rule for anonymous users
        var defaultRule = new RateLimitRule
        {
            RequestsPerMinute = 20,
            RequestsPerHour = 500,
            RequestsPerDay = 5000
        };

        // Enhanced limits for authenticated users
        if (!string.IsNullOrEmpty(userRole))
        {
            return userRole switch
            {
                "SuperAdmin" => new RateLimitRule
                {
                    RequestsPerMinute = 200,
                    RequestsPerHour = 10000,
                    RequestsPerDay = 100000
                },
                "Admin" => new RateLimitRule
                {
                    RequestsPerMinute = 100,
                    RequestsPerHour = 5000,
                    RequestsPerDay = 50000
                },
                "User" => new RateLimitRule
                {
                    RequestsPerMinute = 60,
                    RequestsPerHour = 2000,
                    RequestsPerDay = 20000
                },
                _ => defaultRule
            };
        }

        return defaultRule;
    }

    private async Task LogSecurityEventAsync(string eventType, string identifier, 
        string endpoint, string details, int? userId)
    {
        // Integration with security monitoring system
        _logger.LogWarning("Security Event: {EventType} - Identifier: {Identifier}, " +
                          "Endpoint: {Endpoint}, Details: {Details}, UserId: {UserId}",
            eventType, identifier, endpoint, details, userId);
    }
}
```

#### 1.4 Rate Limiting Middleware
**File**: `src/Api/Middleware/RateLimitingMiddleware.cs`
```csharp
public class RateLimitingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IRateLimitService _rateLimitService;
    private readonly ILogger<RateLimitingMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        // Skip rate limiting for health checks and internal endpoints
        if (IsExcludedPath(context.Request.Path))
        {
            await _next(context);
            return;
        }

        var identifier = GetClientIdentifier(context);
        var endpoint = GetEndpointIdentifier(context);
        var userRole = context.User?.FindFirst(ClaimTypes.Role)?.Value;
        var userId = GetUserId(context);

        var rateLimitResult = await _rateLimitService.CheckRateLimitAsync(
            identifier, endpoint, userRole, userId);

        if (!rateLimitResult.IsAllowed)
        {
            context.Response.StatusCode = 429; // Too Many Requests
            context.Response.Headers["X-RateLimit-Limit"] = GetRateLimitHeaders(rateLimitResult);
            context.Response.Headers["X-RateLimit-Remaining"] = "0";
            context.Response.Headers["X-RateLimit-Reset"] = 
                ((DateTimeOffset)rateLimitResult.WindowResetTime).ToUnixTimeSeconds().ToString();
            
            if (rateLimitResult.RetryAfter.HasValue)
            {
                context.Response.Headers["Retry-After"] = 
                    rateLimitResult.RetryAfter.Value.TotalSeconds.ToString("0");
            }

            await context.Response.WriteAsync(JsonSerializer.Serialize(new
            {
                error = "Rate limit exceeded",
                message = rateLimitResult.BlockedReason,
                retryAfter = rateLimitResult.RetryAfter?.TotalSeconds
            }));

            return;
        }

        // Add rate limit info to response headers
        context.Response.OnStarting(() =>
        {
            context.Response.Headers["X-RateLimit-Remaining"] = 
                rateLimitResult.RequestsRemaining.ToString();
            context.Response.Headers["X-RateLimit-Reset"] = 
                ((DateTimeOffset)rateLimitResult.WindowResetTime).ToUnixTimeSeconds().ToString();
            return Task.CompletedTask;
        });

        await _next(context);
    }

    private string GetClientIdentifier(HttpContext context)
    {
        // Priority: User ID > API Key > IP Address
        var userId = GetUserId(context);
        if (userId.HasValue)
        {
            return $"user:{userId}";
        }

        var apiKey = context.Request.Headers["X-API-Key"].FirstOrDefault();
        if (!string.IsNullOrEmpty(apiKey))
        {
            return $"apikey:{apiKey.Substring(0, Math.Min(8, apiKey.Length))}";
        }

        var clientIp = context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
        return $"ip:{clientIp}";
    }

    private string GetEndpointIdentifier(HttpContext context)
    {
        var path = context.Request.Path.Value?.ToLowerInvariant() ?? "";
        var method = context.Request.Method.ToUpperInvariant();
        
        // Group similar endpoints
        if (path.Contains("/api/personality"))
            return "personality-api";
        if (path.Contains("/api/conversation"))
            return "conversation-api";
        if (path.Contains("/api/auth"))
            return "auth-api";
        if (path.Contains("/api/telegram"))
            return "telegram-api";
        
        return $"{method}:{path}";
    }

    private int? GetUserId(HttpContext context)
    {
        var userIdClaim = context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        return int.TryParse(userIdClaim, out var userId) ? userId : null;
    }

    private bool IsExcludedPath(string path)
    {
        var excludedPaths = new[] { "/health", "/metrics", "/swagger" };
        return excludedPaths.Any(excluded => path.StartsWith(excluded, StringComparison.OrdinalIgnoreCase));
    }
}
```

### Task 2: Input Validation & Sanitization (4 hours)

#### 2.1 Input Validation Service
**File**: `src/Core/Services/InputValidationService.cs`
```csharp
public interface IInputValidationService
{
    ValidationResult ValidateAndSanitize<T>(T input) where T : class;
    string SanitizeHtml(string input);
    string SanitizeSql(string input);
    bool ContainsSuspiciousContent(string input);
    ValidationResult ValidatePersonalityData(object personalityData);
}

public class ValidationResult
{
    public bool IsValid { get; set; } = true;
    public List<string> Errors { get; set; } = new();
    public object? SanitizedInput { get; set; }
    public SecurityThreat? ThreatDetected { get; set; }
}

public class SecurityThreat
{
    public string Type { get; set; } = null!;
    public string Description { get; set; } = null!;
    public int SeverityLevel { get; set; } // 1-10
    public string DetectedPattern { get; set; } = null!;
}

public class InputValidationService : IInputValidationService
{
    private readonly ILogger<InputValidationService> _logger;

    // Suspicious patterns for security threats
    private readonly Dictionary<string, Regex> _threatPatterns = new()
    {
        ["SqlInjection"] = new Regex(@"(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|ALTER)\b)|([';])", 
            RegexOptions.IgnoreCase),
        ["XssScript"] = new Regex(@"<script[^>]*>.*?</script>|javascript:|on\w+\s*=", 
            RegexOptions.IgnoreCase | RegexOptions.Singleline),
        ["CommandInjection"] = new Regex(@"(\||&|;|\$\(|\`|<|>)", 
            RegexOptions.IgnoreCase),
        ["PathTraversal"] = new Regex(@"(\.\./|\.\.\\|%2e%2e%2f|%2e%2e%5c)", 
            RegexOptions.IgnoreCase)
    };

    public ValidationResult ValidateAndSanitize<T>(T input) where T : class
    {
        var result = new ValidationResult();
        
        if (input == null)
        {
            result.IsValid = false;
            result.Errors.Add("Input cannot be null");
            return result;
        }

        var properties = typeof(T).GetProperties();
        var sanitizedObject = Activator.CreateInstance<T>();

        foreach (var property in properties)
        {
            if (property.PropertyType == typeof(string))
            {
                var value = property.GetValue(input) as string;
                if (!string.IsNullOrEmpty(value))
                {
                    // Check for threats
                    var threat = DetectThreats(value);
                    if (threat != null)
                    {
                        result.ThreatDetected = threat;
                        result.IsValid = false;
                        result.Errors.Add($"Security threat detected in {property.Name}: {threat.Description}");
                        
                        // Log security incident
                        LogSecurityThreat(threat, property.Name, value);
                        continue;
                    }

                    // Sanitize the value
                    var sanitizedValue = SanitizeString(value);
                    property.SetValue(sanitizedObject, sanitizedValue);
                }
            }
            else
            {
                // Copy non-string properties as-is
                property.SetValue(sanitizedObject, property.GetValue(input));
            }
        }

        result.SanitizedInput = sanitizedObject;
        return result;
    }

    public ValidationResult ValidatePersonalityData(object personalityData)
    {
        var result = new ValidationResult();
        
        if (personalityData is JsonElement jsonElement)
        {
            var jsonString = jsonElement.GetRawText();
            
            // Check JSON size (prevent DoS attacks)
            if (jsonString.Length > 100_000) // 100KB limit
            {
                result.IsValid = false;
                result.Errors.Add("Personality data exceeds maximum size limit");
                return result;
            }

            // Check for nested depth (prevent stack overflow)
            if (GetJsonDepth(jsonElement) > 10)
            {
                result.IsValid = false;
                result.Errors.Add("Personality data structure too deeply nested");
                return result;
            }

            // Validate content for threats
            var threat = DetectThreats(jsonString);
            if (threat != null)
            {
                result.IsValid = false;
                result.ThreatDetected = threat;
                result.Errors.Add($"Security threat in personality data: {threat.Description}");
            }
        }

        return result;
    }

    private SecurityThreat? DetectThreats(string input)
    {
        foreach (var (threatType, pattern) in _threatPatterns)
        {
            if (pattern.IsMatch(input))
            {
                return new SecurityThreat
                {
                    Type = threatType,
                    Description = GetThreatDescription(threatType),
                    SeverityLevel = GetThreatSeverity(threatType),
                    DetectedPattern = pattern.Match(input).Value
                };
            }
        }

        return null;
    }

    private string SanitizeString(string input)
    {
        if (string.IsNullOrEmpty(input)) return input;

        // HTML encode dangerous characters
        input = HttpUtility.HtmlEncode(input);
        
        // Remove null bytes
        input = input.Replace("\0", "");
        
        // Normalize whitespace
        input = Regex.Replace(input, @"\s+", " ").Trim();
        
        return input;
    }

    private int GetJsonDepth(JsonElement element, int currentDepth = 0)
    {
        if (currentDepth > 15) return currentDepth; // Prevent infinite recursion

        var maxChildDepth = currentDepth;
        
        switch (element.ValueKind)
        {
            case JsonValueKind.Object:
                foreach (var property in element.EnumerateObject())
                {
                    var childDepth = GetJsonDepth(property.Value, currentDepth + 1);
                    maxChildDepth = Math.Max(maxChildDepth, childDepth);
                }
                break;
            
            case JsonValueKind.Array:
                foreach (var item in element.EnumerateArray())
                {
                    var childDepth = GetJsonDepth(item, currentDepth + 1);
                    maxChildDepth = Math.Max(maxChildDepth, childDepth);
                }
                break;
        }

        return maxChildDepth;
    }

    private string GetThreatDescription(string threatType) => threatType switch
    {
        "SqlInjection" => "Potential SQL injection attempt detected",
        "XssScript" => "Cross-site scripting (XSS) attempt detected",
        "CommandInjection" => "Command injection attempt detected",
        "PathTraversal" => "Path traversal attack detected",
        _ => "Unknown security threat detected"
    };

    private int GetThreatSeverity(string threatType) => threatType switch
    {
        "SqlInjection" => 9,
        "CommandInjection" => 9,
        "XssScript" => 7,
        "PathTraversal" => 6,
        _ => 5
    };

    private void LogSecurityThreat(SecurityThreat threat, string fieldName, string originalValue)
    {
        _logger.LogWarning("Security threat detected - Type: {ThreatType}, Field: {FieldName}, " +
                          "Severity: {Severity}, Pattern: {Pattern}, Original: {Original}",
            threat.Type, fieldName, threat.SeverityLevel, threat.DetectedPattern, 
            originalValue.Substring(0, Math.Min(100, originalValue.Length)));
    }
}
```

#### 2.2 Input Validation Filter
**File**: `src/Api/Filters/InputValidationFilter.cs`
```csharp
public class InputValidationFilter : IActionFilter
{
    private readonly IInputValidationService _inputValidationService;
    private readonly ILogger<InputValidationFilter> _logger;

    public void OnActionExecuting(ActionExecutingContext context)
    {
        foreach (var parameter in context.ActionArguments)
        {
            if (parameter.Value != null && IsComplexType(parameter.Value.GetType()))
            {
                var validationResult = _inputValidationService.ValidateAndSanitize(parameter.Value);
                
                if (!validationResult.IsValid)
                {
                    // Security threat detected
                    if (validationResult.ThreatDetected != null)
                    {
                        var threat = validationResult.ThreatDetected;
                        
                        // High severity threats - block immediately
                        if (threat.SeverityLevel >= 8)
                        {
                            context.Result = new BadRequestObjectResult(new
                            {
                                error = "Invalid input detected",
                                message = "Request blocked due to security policy"
                            });
                            return;
                        }
                    }

                    // Regular validation errors
                    context.Result = new BadRequestObjectResult(new
                    {
                        error = "Validation failed",
                        errors = validationResult.Errors
                    });
                    return;
                }

                // Replace original input with sanitized version
                if (validationResult.SanitizedInput != null)
                {
                    context.ActionArguments[parameter.Key] = validationResult.SanitizedInput;
                }
            }
        }
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Post-action validation if needed
    }

    private bool IsComplexType(Type type)
    {
        return !type.IsPrimitive && type != typeof(string) && type != typeof(DateTime) && 
               type != typeof(decimal) && type != typeof(Guid);
    }
}
```

### Task 3: API Key Management System (5 hours)

#### 3.1 API Key Entity & Configuration
**File**: `src/Core/Entities/ApiKey.cs`
```csharp
public class ApiKey : BaseEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = null!; // Friendly name for the key
    public string KeyHash { get; set; } = null!; // Hashed version of the key
    public string KeyPreview { get; set; } = null!; // First 8 characters for display
    public int? OwnerId { get; set; } // User who owns this key
    public User? Owner { get; set; }
    public DateTime ExpiresAt { get; set; }
    public bool IsActive { get; set; } = true;
    public DateTime? LastUsedAt { get; set; }
    public long RequestCount { get; set; } = 0;
    public ApiKeyScope Scope { get; set; } = ApiKeyScope.ReadOnly;
    public string[]? AllowedEndpoints { get; set; }
    public string[]? AllowedIpRanges { get; set; }
}

[Flags]
public enum ApiKeyScope
{
    ReadOnly = 1,
    PersonalityRead = 2,
    PersonalityWrite = 4,
    ConversationRead = 8,
    ConversationWrite = 16,
    AdminAccess = 32,
    FullAccess = ReadOnly | PersonalityRead | PersonalityWrite | 
                ConversationRead | ConversationWrite
}
```

#### 3.2 API Key Service
**File**: `src/Core/Services/ApiKeyService.cs`
```csharp
public interface IApiKeyService
{
    Task<ApiKeyCreationResult> CreateApiKeyAsync(CreateApiKeyRequest request, int userId);
    Task<ApiKey?> ValidateApiKeyAsync(string apiKey);
    Task<bool> RevokeApiKeyAsync(int apiKeyId, int userId);
    Task<List<ApiKeyDto>> GetUserApiKeysAsync(int userId);
    Task<bool> IsEndpointAllowedAsync(string apiKeyHash, string endpoint);
    Task UpdateLastUsedAsync(int apiKeyId);
}

public class CreateApiKeyRequest
{
    [Required]
    public string Name { get; set; } = null!;
    public ApiKeyScope Scope { get; set; } = ApiKeyScope.ReadOnly;
    public DateTime? ExpiresAt { get; set; }
    public string[]? AllowedEndpoints { get; set; }
    public string[]? AllowedIpRanges { get; set; }
}

public class ApiKeyCreationResult
{
    public bool Success { get; set; }
    public string? ApiKey { get; set; } // Plain text key (only returned once)
    public ApiKeyDto? ApiKeyInfo { get; set; }
    public string? Error { get; set; }
}

public class ApiKeyService : IApiKeyService
{
    private readonly IGenericRepository<ApiKey> _apiKeyRepository;
    private readonly ILogger<ApiKeyService> _logger;

    public async Task<ApiKeyCreationResult> CreateApiKeyAsync(CreateApiKeyRequest request, int userId)
    {
        try
        {
            // Generate cryptographically secure API key
            var plainTextKey = GenerateApiKey();
            var keyHash = BCrypt.Net.BCrypt.HashPassword(plainTextKey, workFactor: 12);
            var keyPreview = plainTextKey.Substring(0, 8) + "...";

            var apiKey = new ApiKey
            {
                Name = request.Name,
                KeyHash = keyHash,
                KeyPreview = keyPreview,
                OwnerId = userId,
                ExpiresAt = request.ExpiresAt ?? DateTime.UtcNow.AddYears(1),
                Scope = request.Scope,
                AllowedEndpoints = request.AllowedEndpoints,
                AllowedIpRanges = request.AllowedIpRanges,
                CreatedBy = userId,
                CreatedAt = DateTime.UtcNow
            };

            await _apiKeyRepository.AddAsync(apiKey);

            return new ApiKeyCreationResult
            {
                Success = true,
                ApiKey = plainTextKey, // Only time we return the plain text key
                ApiKeyInfo = new ApiKeyDto
                {
                    Id = apiKey.Id,
                    Name = apiKey.Name,
                    KeyPreview = apiKey.KeyPreview,
                    ExpiresAt = apiKey.ExpiresAt,
                    Scope = apiKey.Scope.ToString(),
                    IsActive = apiKey.IsActive,
                    CreatedAt = apiKey.CreatedAt
                }
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create API key for user {UserId}", userId);
            return new ApiKeyCreationResult
            {
                Success = false,
                Error = "Failed to create API key"
            };
        }
    }

    public async Task<ApiKey?> ValidateApiKeyAsync(string apiKey)
    {
        // Extract API key ID from the key format (e.g., "dk_live_1234567890abcdef...")
        if (!TryExtractApiKeyId(apiKey, out var keyId))
        {
            return null;
        }

        var storedApiKey = await _apiKeyRepository.GetByIdAsync(keyId);
        
        if (storedApiKey == null || !storedApiKey.IsActive || storedApiKey.ExpiresAt < DateTime.UtcNow)
        {
            return null;
        }

        // Verify the key using BCrypt
        if (!BCrypt.Net.BCrypt.Verify(apiKey, storedApiKey.KeyHash))
        {
            return null;
        }

        // Update last used timestamp (async fire-and-forget)
        _ = Task.Run(() => UpdateLastUsedAsync(storedApiKey.Id));

        return storedApiKey;
    }

    private string GenerateApiKey()
    {
        // Format: "dk_live_" + 32 random hex characters
        var randomBytes = new byte[16];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(randomBytes);
        
        var randomHex = Convert.ToHexString(randomBytes).ToLowerInvariant();
        return $"dk_live_{randomHex}";
    }

    private bool TryExtractApiKeyId(string apiKey, out int keyId)
    {
        keyId = 0;
        
        // For this implementation, we'll hash the key and look it up
        // In a production system, you might embed the ID in the key format
        return true; // Simplified for example
    }

    public async Task<bool> IsEndpointAllowedAsync(string apiKeyHash, string endpoint)
    {
        var apiKey = await _apiKeyRepository.FindAsync(k => k.KeyHash == apiKeyHash);
        
        if (apiKey == null) return false;

        // Check endpoint restrictions
        if (apiKey.AllowedEndpoints != null && apiKey.AllowedEndpoints.Length > 0)
        {
            return apiKey.AllowedEndpoints.Any(allowed => 
                endpoint.StartsWith(allowed, StringComparison.OrdinalIgnoreCase));
        }

        return true; // No restrictions means all endpoints allowed
    }
}
```

#### 3.3 API Key Authentication Middleware
**File**: `src/Api/Middleware/ApiKeyAuthenticationMiddleware.cs`
```csharp
public class ApiKeyAuthenticationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IApiKeyService _apiKeyService;
    private readonly ILogger<ApiKeyAuthenticationMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        var apiKey = ExtractApiKey(context.Request);
        
        if (!string.IsNullOrEmpty(apiKey))
        {
            var validApiKey = await _apiKeyService.ValidateApiKeyAsync(apiKey);
            
            if (validApiKey != null)
            {
                // Check endpoint permissions
                var endpoint = context.Request.Path.Value ?? "";
                if (await _apiKeyService.IsEndpointAllowedAsync(validApiKey.KeyHash, endpoint))
                {
                    // Create API key-based identity
                    var claims = new List<Claim>
                    {
                        new("api_key_id", validApiKey.Id.ToString()),
                        new("api_key_scope", validApiKey.Scope.ToString()),
                        new("auth_method", "api_key")
                    };

                    if (validApiKey.OwnerId.HasValue)
                    {
                        claims.Add(new(ClaimTypes.NameIdentifier, validApiKey.OwnerId.Value.ToString()));
                    }

                    var identity = new ClaimsIdentity(claims, "ApiKey");
                    context.User = new ClaimsPrincipal(identity);

                    // Add API key info to response headers (for debugging)
                    context.Response.OnStarting(() =>
                    {
                        context.Response.Headers["X-API-Key-Preview"] = validApiKey.KeyPreview;
                        return Task.CompletedTask;
                    });
                }
                else
                {
                    context.Response.StatusCode = 403;
                    await context.Response.WriteAsync("API key does not have access to this endpoint");
                    return;
                }
            }
            else
            {
                context.Response.StatusCode = 401;
                await context.Response.WriteAsync("Invalid API key");
                return;
            }
        }

        await _next(context);
    }

    private string? ExtractApiKey(HttpRequest request)
    {
        // Check Authorization header (Bearer token)
        var authHeader = request.Headers.Authorization.FirstOrDefault();
        if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith("Bearer "))
        {
            var token = authHeader.Substring(7);
            if (token.StartsWith("dk_"))
            {
                return token;
            }
        }

        // Check X-API-Key header
        var apiKeyHeader = request.Headers["X-API-Key"].FirstOrDefault();
        if (!string.IsNullOrEmpty(apiKeyHeader))
        {
            return apiKeyHeader;
        }

        // Check query parameter (less secure, for development only)
        var apiKeyQuery = request.Query["api_key"].FirstOrDefault();
        if (!string.IsNullOrEmpty(apiKeyQuery))
        {
            return apiKeyQuery;
        }

        return null;
    }
}
```

### Task 4: Security Headers & CORS (2 hours)

#### 4.1 Security Headers Middleware
**File**: `src/Api/Middleware/SecurityHeadersMiddleware.cs`
```csharp
public class SecurityHeadersMiddleware
{
    private readonly RequestDelegate _next;
    private readonly SecurityHeadersOptions _options;

    public SecurityHeadersMiddleware(RequestDelegate next, SecurityHeadersOptions options)
    {
        _next = next;
        _options = options;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Add security headers
        var response = context.Response;

        // Content Security Policy
        if (!string.IsNullOrEmpty(_options.ContentSecurityPolicy))
        {
            response.Headers["Content-Security-Policy"] = _options.ContentSecurityPolicy;
        }

        // Strict Transport Security (HTTPS only)
        if (context.Request.IsHttps)
        {
            response.Headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains";
        }

        // X-Frame-Options
        response.Headers["X-Frame-Options"] = "DENY";

        // X-Content-Type-Options
        response.Headers["X-Content-Type-Options"] = "nosniff";

        // Referrer-Policy
        response.Headers["Referrer-Policy"] = "strict-origin-when-cross-origin";

        // Permissions-Policy
        response.Headers["Permissions-Policy"] = 
            "geolocation=(), microphone=(), camera=(), payment=(), usb=()";

        // Remove sensitive headers
        response.Headers.Remove("Server");
        response.Headers.Remove("X-Powered-By");
        response.Headers.Remove("X-AspNet-Version");

        await _next(context);
    }
}

public class SecurityHeadersOptions
{
    public string ContentSecurityPolicy { get; set; } = 
        "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; " +
        "img-src 'self' data:; font-src 'self'; connect-src 'self'; " +
        "frame-ancestors 'none'; base-uri 'self'; form-action 'self';";
}
```

#### 4.2 Enhanced CORS Configuration
**File**: `src/Api/Configuration/CorsConfiguration.cs`
```csharp
public static class CorsConfiguration
{
    public static void ConfigureCors(this IServiceCollection services, IConfiguration configuration)
    {
        var allowedOrigins = configuration.GetSection("Cors:AllowedOrigins").Get<string[]>() 
                           ?? new[] { "https://localhost:3000" };

        services.AddCors(options =>
        {
            options.AddPolicy("ProductionCorsPolicy", builder =>
            {
                builder.WithOrigins(allowedOrigins)
                       .WithMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                       .WithHeaders("Content-Type", "Authorization", "X-API-Key")
                       .AllowCredentials()
                       .SetPreflightMaxAge(TimeSpan.FromMinutes(5));
            });

            options.AddPolicy("DevelopmentCorsPolicy", builder =>
            {
                builder.AllowAnyOrigin()
                       .AllowAnyMethod()
                       .AllowAnyHeader();
            });
        });
    }
}
```

### Task 5: Enhanced Error Handling & Logging (2 hours)

#### 4.3 Global Exception Handler
**File**: `src/Api/Middleware/GlobalExceptionMiddleware.cs`
```csharp
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;
    private readonly IWebHostEnvironment _environment;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var correlationId = context.TraceIdentifier;
        var userId = context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;

        _logger.LogError(exception, "Unhandled exception occurred. CorrelationId: {CorrelationId}, " +
                                   "UserId: {UserId}, Path: {Path}, Method: {Method}",
            correlationId, userId, context.Request.Path, context.Request.Method);

        context.Response.ContentType = "application/json";

        var (statusCode, message) = exception switch
        {
            SecurityException => (401, "Access denied"),
            UnauthorizedAccessException => (401, "Unauthorized"),
            ArgumentException => (400, "Invalid request"),
            InvalidOperationException => (400, "Invalid operation"),
            TimeoutException => (408, "Request timeout"),
            _ => (500, "An error occurred while processing your request")
        };

        context.Response.StatusCode = statusCode;

        var response = new
        {
            error = message,
            correlationId = correlationId,
            timestamp = DateTime.UtcNow,
            details = _environment.IsDevelopment() ? exception.Message : null
        };

        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

---

## ‚úÖ VALIDATION & TESTING

### Security Testing Commands
```bash
# Test rate limiting
for i in {1..100}; do curl -X GET "http://localhost:5000/api/personality" & done

# Test input validation
curl -X POST "http://localhost:5000/api/personality" \
     -H "Content-Type: application/json" \
     -d '{"name":"<script>alert(\"xss\")</script>","data":"SELECT * FROM users"}'

# Test API key authentication
curl -X GET "http://localhost:5000/api/personality" \
     -H "X-API-Key: dk_live_1234567890abcdef"

# Security headers validation
curl -I "http://localhost:5000/api/health"
```

### Performance Validation
```bash
# Rate limiting performance test
ab -n 1000 -c 10 -H "Authorization: Bearer <valid-jwt>" \
   http://localhost:5000/api/personality

# Input validation performance
ab -n 500 -c 5 -p test-payload.json -T application/json \
   http://localhost:5000/api/personality
```

---

## üîó INTEGRATION POINTS

### P3.1.1 JWT Authentication Integration
- **User-Based Rate Limiting**: Different limits for authenticated vs anonymous users
- **Role-Based API Access**: Admin endpoints with elevated security
- **Audit Trail**: Security events logged with user context

### P3.1.3 Production Monitoring Integration
- **Security Metrics**: Rate limit violations, threat detections, API key usage
- **Alert Rules**: Critical security events trigger immediate notifications
- **Dashboards**: Real-time security monitoring with threat visualization

### Next Component Preparation
- **P3.1.3**: Security events and metrics feed into monitoring dashboards
- **P3.1.4**: Security configurations included in deployment pipeline
- **P3.1.5**: Security testing scenarios for integration validation

---

**COMPONENT SUMMARY**: P3.1.2 implements comprehensive API security hardening with Redis-based rate limiting, input validation, API key management, security headers, and enhanced error handling. Provides robust protection against common attack vectors while maintaining high performance.

**CRITICAL SUCCESS FACTORS**: Zero critical vulnerabilities, sub-100ms security validation, comprehensive threat detection, seamless integration with P3.1.1 authentication system.