---
description: "Применять при проверке соблюдения принципов разработки и архитектурных паттернов. Ключевые слова: 'принципы', 'SOLID', 'DRY', 'KISS', 'архитектура', 'design patterns', 'принципы разработки', 'software principles', 'code principles', 'нарушение принципов', 'архитектурные нарушения'."
globs: **
alwaysApply: false
---

# Принципы разработки программного обеспечения

## SOLID Принципы

### Single Responsibility Principle (SRP)
- Каждый класс должен иметь только одну причину для изменения
- Класс должен быть ответственен только за одну функциональность
- ❌ **Нарушение**: класс `UserService` одновременно валидирует данные, сохраняет в БД и отправляет email
- ✅ **Соблюдение**: `UserValidator`, `UserRepository`, `EmailService` - отдельные классы

### Open/Closed Principle (OCP)
- Классы должны быть открыты для расширения, но закрыты для модификации
- Новую функциональность добавляем через наследование/композицию, а не изменение существующего кода
- ❌ **Нарушение**: добавление нового типа оплаты требует изменения класса `PaymentProcessor`
- ✅ **Соблюдение**: интерфейс `IPaymentMethod` + отдельные реализации для каждого типа

### Liskov Substitution Principle (LSP)
- Объекты базового класса должны заменяться объектами наследников без нарушения корректности программы
- Наследники не должны усиливать предусловия или ослаблять постусловия
- ❌ **Нарушение**: `Rectangle.SetWidth()` в наследнике `Square` меняет и высоту
- ✅ **Соблюдение**: правильная иерархия с `Shape` базовым классом

### Interface Segregation Principle (ISP)
- Клиенты не должны зависеть от интерфейсов, которые они не используют
- Лучше много специфичных интерфейсов, чем один универсальный
- ❌ **Нарушение**: `IWorker` с методами `Work()` и `Eat()` - роботы не едят
- ✅ **Соблюдение**: `IWorkable` и `IFeedable` интерфейсы отдельно

### Dependency Inversion Principle (DIP)
- Модули высокого уровня не должны зависеть от модулей низкого уровня - оба должны зависеть от абстракций
- Абстракции не должны зависеть от деталей - детали должны зависеть от абстракций
- ❌ **Нарушение**: `UserService` напрямую создает `SqlUserRepository`
- ✅ **Соблюдение**: `UserService` принимает `IUserRepository` в конструкторе

## DRY Principle (Don't Repeat Yourself)

### Основные правила
- Каждое знание должно иметь единственное, недвусмысленное представление в системе
- Дублирование кода ведет к проблемам сопровождения
- Не копируй код - выноси в методы, классы, утилиты

### Типы дублирования
- **Code Duplication**: одинаковые блоки кода
- **Data Duplication**: дублирование данных в разных местах
- **Logic Duplication**: одна и та же бизнес-логика в разных местах
- **API Duplication**: похожие методы с небольшими отличиями

### Рефакторинг дублирования
```csharp
// ❌ Дублирование кода
public void ProcessUser() { /* 50 lines */ }
public void ProcessAdmin() { /* те же 50 lines + 2 отличия */ }

// ✅ Вынос общей логики
/// <summary>
/// Обрабатывает сущность с возможностью дополнительной логики для администраторов.
/// </summary>
/// <param name="entity">Сущность для обработки</param>
/// <param name="isAdmin">Признак администратора</param>
public void ProcessEntity(IEntity entity, bool isAdmin = false)
{
    // общая логика
    if (isAdmin)
    {
        // специфика для админа
    }
}
```

## KISS Principle (Keep It Simple, Stupid)

### Принцип простоты
- Простые решения лучше сложных
- Если можно решить проще - решай проще
- Избегай over-engineering и преждевременных оптимизаций
- Предпочитай явное неявному

### Признаки нарушения KISS
- Сложные цепочки наследования без необходимости
- Избыточные абстракции для простой функциональности
- Сложные паттерны там, где достаточно простого решения
- Неоправданно сложная архитектура

## YAGNI Principle (You Aren't Gonna Need It)

### Принцип необходимости
- Не реализуй функциональность, пока она не понадобится
- Не создавай абстракции "на будущее"
- Сосредоточься на текущих требованиях

## Fail-Fast Principle

### Принцип раннего обнаружения ошибок
- Обнаруживай и сообщай об ошибках как можно раньше
- Не позволяй системе работать в некорректном состоянии
- Валидируй входные данные в начале методов
- Используй ранние выходы из методов при обнаружении проблем

### Применение Fail-Fast
```csharp
// ✅ Fail-fast с валидацией
/// <summary>
/// Обрабатывает пользователя с проверкой входных параметров по принципу fail-fast.
/// </summary>
/// <param name="user">Пользователь для обработки</param>
/// <exception cref="ArgumentNullException">Если user равен null</exception>
/// <exception cref="ArgumentException">Если email пользователя отсутствует</exception>
public void ProcessUser(User user)
{
    if (user == null)
    {
        throw new ArgumentNullException(nameof(user));
    }

    if (string.IsNullOrEmpty(user.Email))
    {
        throw new ArgumentException("Email is required", nameof(user));
    }

    // основная логика только после валидации
}
```

### Fast-Return Pattern
- Используй ранние выходы вместо глубокой вложенности
- Сначала проверяй граничные случаи и ошибки
- Основную логику оставляй на самом нижнем уровне вложенности

```csharp
// ❌ Глубокая вложенность
public string ProcessData(string input)
{
    if (!string.IsNullOrEmpty(input))
    {
        if (input.Length > 10)
        {
            if (IsValid(input))
            {
                return Transform(input);
            }
        }
    }
    return null;
}

// ✅ Fast-return pattern
/// <summary>
/// Обрабатывает входные данные с применением паттерна fast-return.
/// </summary>
/// <param name="input">Строка для обработки</param>
/// <returns>Обработанные данные или null при невалидном входе</returns>
public string ProcessData(string input)
{
    if (string.IsNullOrEmpty(input))
    {
        return null;
    }

    if (input.Length <= 10)
    {
        return null;
    }

    if (!IsValid(input))
    {
        return null;
    }

    return Transform(input);
}
```

## Принципы композиции

### Composition over Inheritance
- Предпочитай композицию наследованию
- Используй наследование только для отношений "is-a"
- Для отношений "has-a" используй композицию

### Dependency Injection
- Не создавай зависимости внутри класса
- Получай зависимости извне (конструктор, свойства, методы)
- Это обеспечивает тестируемость и гибкость

## Принципы обработки ошибок

### Error Handling Best Practices
- Обрабатывай ошибки на правильном уровне абстракции
- Не глотай исключения без логирования
- Используй специфичные типы исключений
- Предоставляй полезную информацию в сообщениях об ошибках

## Принципы производительности

### Performance Principles
- Измеряй перед оптимизацией
- Оптимизируй узкие места, а не случайный код
- Избегай преждевременных оптимизаций
- Помни о читаемости кода при оптимизации