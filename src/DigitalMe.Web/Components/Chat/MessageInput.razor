@inject IJSRuntime Js

<div class="message-input-container">
    <div class="input-wrapper">
        <textarea @ref="_textareaRef" 
                  @bind="_currentMessage" 
                  @bind:event="oninput"
                  @bind:after="@HandleInputWithStateChange"
                  @onkeypress="@HandleKeyPress"
                  placeholder="@Placeholder"
                  disabled="@IsLoading"
                  class="message-textarea"
                  rows="1"></textarea>
        
        <div class="input-actions">
            <button type="button" 
                    @onclick="@HandleSendClick"
                    disabled="@(IsLoading || string.IsNullOrWhiteSpace(_currentMessage))"
                    class="send-button"
                    title="@GetButtonTitle()">
                @if (IsLoading)
                {
                    <div class="loading-spinner"></div>
                }
                else
                {
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2,21L23,12L2,3V10L17,12L2,14V21Z" />
                    </svg>
                }
            </button>
        </div>
    </div>
    
    <div class="input-hints">
        <span class="hint">Enter для отправки • Shift+Enter для новой строки • Поддержка кода в ```блоках```</span>
        @if (!string.IsNullOrEmpty(_currentMessage))
        {
            <span class="char-count">@_currentMessage.Length</span>
        }
    </div>
</div>

<style>
.message-input-container {
    width: 100%;
}

.input-wrapper {
    display: flex;
    align-items: flex-end;
    background: white;
    border: 2px solid #e0e0e0;
    border-radius: 24px;
    padding: 8px 12px;
    transition: border-color 0.2s ease;
}

.input-wrapper:focus-within {
    border-color: #1a237e;
}

.message-textarea {
    flex: 1;
    border: none;
    outline: none;
    resize: none;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 14px;
    line-height: 1.4;
    padding: 8px 12px;
    background: transparent;
    max-height: 120px;
    min-height: 20px;
}

.message-textarea:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.message-textarea::placeholder {
    color: #9e9e9e;
}

.input-actions {
    display: flex;
    align-items: center;
    margin-left: 8px;
}

.send-button {
    width: 44px;
    height: 44px;
    border: none;
    border-radius: 50%;
    background: linear-gradient(135deg, #ff6f00 0%, #ff9800 100%);
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(255, 111, 0, 0.3);
}

.send-button:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(255, 111, 0, 0.4);
}

.send-button:active:not(:disabled) {
    transform: translateY(0);
}

.send-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 4px rgba(255, 111, 0, 0.2);
}

.loading-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid transparent;
    border-top: 2px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

/* spin animation moved to components.css */

.input-hints {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    padding: 0 4px;
    font-size: 12px;
    color: #9e9e9e;
}

.hint {
    font-family: 'Roboto Mono', monospace;
}

.char-count {
    font-family: 'Roboto Mono', monospace;
    color: #757575;
}
</style>

@code {
    [Parameter] public EventCallback<string> OnMessageSent { get; set; }
    [Parameter] public bool IsLoading { get; set; }
    [Parameter] public string Placeholder { get; set; } = "Напиши сообщение...";
    
    private ElementReference _textareaRef;
    private string _currentMessage = string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Js.InvokeVoidAsync("initializeTextarea", _textareaRef);
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (e.CtrlKey || !e.ShiftKey)
            {
                // Send on Enter or Ctrl+Enter
                await SendMessage();
            }
            // Shift+Enter adds new line (browser default)
        }
    }

    private async Task HandleInput()
    {
        // Auto-resize textarea
        await Js.InvokeVoidAsync("autoResizeTextarea", _textareaRef);
    }

    private async Task HandleInputWithStateChange()
    {
        // Auto-resize textarea
        try
        {
            await Js.InvokeVoidAsync("autoResizeTextarea", _textareaRef);
        }
        catch (Exception ex)
        {
            // Ignore JS errors during prerendering
            Console.WriteLine($"JS resize error: {ex.Message}");
        }
        
        // Force UI update to enable/disable send button
        StateHasChanged();
    }

    private async Task HandleSendClick()
    {
        await SendMessage();
    }

    private async Task SendMessage()
    {
        if (IsLoading || string.IsNullOrWhiteSpace(_currentMessage))
            return;

        var message = _currentMessage.Trim();
        _currentMessage = string.Empty;

        // Reset textarea height
        await Js.InvokeVoidAsync("resetTextareaHeight", _textareaRef);
        
        // Focus back to textarea
        await _textareaRef.FocusAsync();
        
        await OnMessageSent.InvokeAsync(message);
    }

    private string GetButtonTitle()
    {
        if (IsLoading) return "Отправка...";
        if (string.IsNullOrWhiteSpace(_currentMessage)) return $"Введите текст (длина: {_currentMessage?.Length ?? 0})";
        return "Отправить сообщение (Ctrl+Enter)";
    }
}