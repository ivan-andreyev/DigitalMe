using System.Diagnostics;
using System.Text.Json;
using DigitalMe.Common;
using DigitalMe.Integrations.MCP.Models;
using DigitalMe.Models;
using DigitalMe.Services;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace DigitalMe.Integrations.MCP;

public class McpServiceProper : IMcpService
{
    private readonly IMcpClient _mcpClient;
    private readonly IAnthropicService _anthropicService; // Fallback
    private readonly ILogger<McpServiceProper> _logger;
    private readonly IPersonalityService _personalityService;
    private readonly IConfiguration _configuration;
    private readonly bool _mcpEnabled;

    public McpServiceProper(
        IMcpClient mcpClient,
        IAnthropicService anthropicService,
        ILogger<McpServiceProper> logger,
        IPersonalityService personalityService,
        IConfiguration configuration)
    {
        _mcpClient = mcpClient;
        _anthropicService = anthropicService;
        _logger = logger;
        _personalityService = personalityService;
        _configuration = configuration;
        _mcpEnabled = _configuration.GetValue<bool>("MCP:Enabled", false);

        _logger.LogInformation("üöÄ McpServiceProper initialized with MCP Enabled: {McpEnabled}", _mcpEnabled);
    }

    public async Task<Result<bool>> InitializeAsync()
    {
        return await ResultExtensions.TryAsync(async () =>
        {
            _logger.LogInformation("üöÄ Initializing MCP Service (proper implementation) - MCP Enabled: {McpEnabled}", _mcpEnabled);

            // If MCP is disabled, skip straight to Anthropic fallback
            if (!_mcpEnabled)
            {
                _logger.LogInformation("‚ö° MCP disabled in configuration, using direct Anthropic");
                var anthropicResult = await _anthropicService.IsConnectedAsync();
                if (anthropicResult.IsSuccess && anthropicResult.Value)
                {
                    _logger.LogInformation("‚úÖ Direct Anthropic connection established (MCP bypassed)");
                    return true;
                }
                _logger.LogError("‚ùå Anthropic unavailable and MCP disabled");
                return false;
            }

            // Try MCP first only if enabled
            var mcpConnected = await _mcpClient.InitializeAsync();
            if (mcpConnected)
            {
                _logger.LogInformation("‚úÖ MCP server connection established");
                return true;
            }

            // Fallback to direct Anthropic
            _logger.LogWarning("‚ö†Ô∏è MCP server unavailable, checking direct Anthropic fallback");
            var anthropicConnectedResult = await _anthropicService.IsConnectedAsync();

            if (anthropicConnectedResult.IsSuccess && anthropicConnectedResult.Value)
            {
                _logger.LogInformation("‚úÖ Using direct Anthropic as fallback");
                return true;
            }

            _logger.LogError("‚ùå Both MCP and Anthropic are unavailable");
            return false;
        }, "Failed to initialize MCP Service");
    }

    public async Task<Result<string>> SendMessageAsync(string message, PersonalityContext context)
    {
        return await ResultExtensions.TryAsync(async () =>
        {
            var stopwatch = Stopwatch.StartNew();
            var messagePreview = message.Substring(0, Math.Min(50, message.Length));

            _logger.LogInformation("üîç SendMessageAsync called with message: '{Message}', MCP Enabled: {McpEnabled}, MCP IsConnected: {IsConnected}",
                messagePreview, _mcpEnabled, _mcpClient.IsConnected);

            try
            {
                string result;
                string path;

                // If MCP is disabled, skip straight to Anthropic for instant response
                if (!_mcpEnabled)
                {
                    _logger.LogInformation("‚ö° MCP disabled - using direct Anthropic (instant fallback)");
                    var anthropicStopwatch = Stopwatch.StartNew();
                    var anthropicResult = await _anthropicService.SendMessageAsync(message, context.Profile);
                    anthropicStopwatch.Stop();

                    if (anthropicResult.IsSuccess)
                    {
                        result = anthropicResult.Value;
                        path = "DirectAnthropic";
                        _logger.LogInformation("‚ö° Direct Anthropic response time: {AnthropicTime}ms", anthropicStopwatch.ElapsedMilliseconds);
                    }
                    else
                    {
                        _logger.LogWarning("Direct Anthropic failed: {Error}", anthropicResult.Error);
                        result = await GenerateFallbackResponseAsync(message, context);
                        path = "StaticFallback";
                    }
                }
                else
                {
                    // MCP is enabled - try MCP first
                    // Try to initialize if not connected
                    if (!_mcpClient.IsConnected)
                    {
                        _logger.LogInformation("üîó MCP not connected, attempting initialization...");
                        var initStopwatch = Stopwatch.StartNew();
                        var initialized = await _mcpClient.InitializeAsync();
                        initStopwatch.Stop();
                        _logger.LogInformation("üîó MCP initialization result: {Result} (took {InitTime}ms)", initialized, initStopwatch.ElapsedMilliseconds);
                    }

                    if (_mcpClient.IsConnected)
                    {
                        var mcpStopwatch = Stopwatch.StartNew();
                        result = await SendMessageViaMcpAsync(message, context);
                        mcpStopwatch.Stop();
                        path = "MCP";
                        _logger.LogInformation("üîó MCP response time: {McpTime}ms", mcpStopwatch.ElapsedMilliseconds);
                    }
                    else
                    {
                        _logger.LogInformation("üìû Using Anthropic fallback (MCP unavailable)");
                        var fallbackStopwatch = Stopwatch.StartNew();
                        var anthropicResult = await _anthropicService.SendMessageAsync(message, context.Profile);
                        fallbackStopwatch.Stop();

                        if (anthropicResult.IsSuccess)
                        {
                            result = anthropicResult.Value;
                            path = "AnthropicFallback";
                            _logger.LogInformation("üìû Anthropic fallback response time: {FallbackTime}ms", fallbackStopwatch.ElapsedMilliseconds);
                        }
                        else
                        {
                            _logger.LogWarning("Anthropic fallback failed: {Error}", anthropicResult.Error);
                            result = await GenerateFallbackResponseAsync(message, context);
                            path = "StaticFallback";
                        }
                    }
                }

                stopwatch.Stop();
                _logger.LogInformation("üéØ PERFORMANCE: Total response time: {TotalTime}ms via {Path} for message: '{Message}'",
                    stopwatch.ElapsedMilliseconds, path, messagePreview);

                return result;
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                _logger.LogError(ex, "üí• PERFORMANCE: Request failed after {TotalTime}ms for message: '{Message}'",
                    stopwatch.ElapsedMilliseconds, messagePreview);
                throw;
            }
        }, $"Failed to send message via MCP: {message.Substring(0, Math.Min(50, message.Length))}");
    }

    private async Task<string> SendMessageViaMcpAsync(string message, PersonalityContext context)
    {
        _logger.LogInformation("üîó Sending message via MCP protocol");

        try
        {
            // Get Ivan's personality for system prompt
            var ivanPersonalityResult = await _personalityService.GetPersonalityAsync();
            var systemPrompt = ivanPersonalityResult.IsSuccess && ivanPersonalityResult.Value != null
                ? _personalityService.GenerateSystemPrompt(ivanPersonalityResult.Value).Value ?? "System prompt unavailable"
                : "Error loading personality profile";

            // Prepare MCP request for conversation
            var request = new McpRequest
            {
                Method = "llm/complete",
                Params = new
                {
                    model = "claude-3-5-sonnet-20241022",
                    systemPrompt = systemPrompt,
                    messages = new[]
                    {
                        new { role = "user", content = message }
                    },
                    maxTokens = 1000,
                    temperature = 0.7,
                    metadata = new
                    {
                        userId = context.CurrentState.GetValueOrDefault("userId", "unknown").ToString(),
                        platform = context.CurrentState.GetValueOrDefault("platform", "unknown").ToString(),
                        conversationId = context.CurrentState.GetValueOrDefault("conversationId", "").ToString(),
                        isRealTime = context.CurrentState.GetValueOrDefault("isRealTime", false)
                    }
                }
            };

            var response = await _mcpClient.SendRequestAsync(request);

            if (response.Error != null)
            {
                _logger.LogError("‚ùå MCP request failed: {ErrorCode} - {ErrorMessage}",
                    response.Error.Code, response.Error.Message);

                // Fallback to direct Anthropic
                var anthropicFallbackResult = await _anthropicService.SendMessageAsync(message, context.Profile);
                return anthropicFallbackResult.IsSuccess && anthropicFallbackResult.Value != null
                    ? anthropicFallbackResult.Value
                    : await GenerateFallbackResponseAsync(message, context);
            }

            if (response.Result?.Content != null)
            {
                var resultText = ExtractContentFromMcpResult(response.Result.Content);
                _logger.LogInformation("‚úÖ MCP response received: {Length} characters", resultText.Length);
                return resultText;
            }

            _logger.LogWarning("‚ö†Ô∏è Empty MCP response, using fallback");
            var anthropicEmptyResult = await _anthropicService.SendMessageAsync(message, context.Profile);
            return anthropicEmptyResult.IsSuccess && anthropicEmptyResult.Value != null
                ? anthropicEmptyResult.Value
                : await GenerateFallbackResponseAsync(message, context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "üí• MCP protocol error, falling back to Anthropic");
            var anthropicErrorResult = await _anthropicService.SendMessageAsync(message, context.Profile);
            return anthropicErrorResult.IsSuccess && anthropicErrorResult.Value != null
                ? anthropicErrorResult.Value
                : await GenerateFallbackResponseAsync(message, context);
        }
    }

    public async Task<Result<McpResponse>> CallToolAsync(string toolName, Dictionary<string, object> parameters)
    {
        return await ResultExtensions.TryAsync(async () =>
        {
            if (_mcpClient.IsConnected)
            {
                _logger.LogInformation("üîß Calling MCP tool: {ToolName}", toolName);
                return await _mcpClient.CallToolAsync(toolName, parameters);
            }
            else
            {
                _logger.LogWarning("‚ö†Ô∏è MCP not connected, cannot call tool: {ToolName}", toolName);
                return new McpResponse
                {
                    Error = new McpError
                    {
                        Code = -32001,
                        Message = "MCP server not connected"
                    }
                };
            }
        }, $"Failed to call MCP tool: {toolName}");
    }

    public async Task<Result<bool>> IsConnectedAsync()
    {
        return await ResultExtensions.TryAsync(async () =>
        {
            // If MCP is disabled, consider the service "connected" via Anthropic fallback
            if (!_mcpEnabled)
            {
                var anthropicResult = await _anthropicService.IsConnectedAsync();
                return anthropicResult.IsSuccess && anthropicResult.Value;
            }

            // MCP is enabled - check MCP connection first
            if (_mcpClient.IsConnected)
            {
                return true;
            }

            // Check fallback Anthropic connection
            var anthropicFallbackResult = await _anthropicService.IsConnectedAsync();
            return anthropicFallbackResult.IsSuccess && anthropicFallbackResult.Value;
        }, "Failed to check MCP service connection status");
    }

    public async Task<Result<bool>> DisconnectAsync()
    {
        return await ResultExtensions.TryAsync(async () =>
        {
            await _mcpClient.DisconnectAsync();
            return true;
        }, "Failed to disconnect MCP service");
    }

    private string ExtractContentFromMcpResult(string resultContent)
    {
        try
        {
            // Try to parse as JSON first
            var jsonResult = JsonSerializer.Deserialize<JsonElement>(resultContent);

            // Look for common response patterns
            if (jsonResult.TryGetProperty("content", out var contentElement))
            {
                return contentElement.GetString() ?? resultContent;
            }

            if (jsonResult.TryGetProperty("text", out var textElement))
            {
                return textElement.GetString() ?? resultContent;
            }

            if (jsonResult.TryGetProperty("message", out var messageElement))
            {
                return messageElement.GetString() ?? resultContent;
            }

            // If it's an array, get first element
            if (jsonResult.ValueKind == JsonValueKind.Array && jsonResult.GetArrayLength() > 0)
            {
                var firstElement = jsonResult[0];
                if (firstElement.TryGetProperty("text", out var arrayTextElement))
                {
                    return arrayTextElement.GetString() ?? resultContent;
                }
            }

            return resultContent;
        }
        catch
        {
            // If parsing fails, return as-is
            return resultContent;
        }
    }

    private async Task<string> GenerateFallbackResponseAsync(string message, PersonalityContext context)
    {
        var ivanProfileResult = await _personalityService.GetPersonalityAsync();
        var ivanProfile = ivanProfileResult.IsSuccess ? ivanProfileResult.Value : null;

        var responses = new[]
        {
            "–°–ª—É—à–∞–π, MCP –ø—Ä–æ—Ç–æ–∫–æ–ª —Å–µ–π—á–∞—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ù—É–∂–Ω–æ –ø–æ–¥–Ω—è—Ç—å MCP —Å–µ—Ä–≤–µ—Ä –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫–∞–∫ –ø–æ–ª–æ–∂–µ–Ω–æ.",
            "–ë–µ–∑ MCP —Å–µ—Ä–≤–µ—Ä–∞ –º–æ–≥—É —Ç–æ–ª—å–∫–æ —Å–∫–∞–∑–∞—Ç—å - –Ω—É–∂–Ω–æ —Ä–∞–∑–±–∏—Ä–∞—Ç—å—Å—è –≤ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ. –£ –º–µ–Ω—è –∫–∞–∫ —É Head of R&D –æ–ø—ã—Ç–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ.",
            "MCP –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —É–ø–∞–ª–∞. –ü—Ä–æ–≤–µ—Ä—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã. –Ø —Ä–∞–±–æ—Ç–∞—é –∑–∞ —Ç—Ä–æ–∏—Ö, –Ω–æ –±–µ–∑ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å–ª–æ–∂–Ω–æ.",
            "–ü—Ä–æ–±–ª–µ–º–∞ —Å MCP –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º. –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ: –æ–ø—Ä–µ–¥–µ–ª–∏ —Ñ–∞–∫—Ç–æ—Ä—ã ‚Üí –ø—Ä–æ–≤–µ—Ä—å –∫–æ–Ω—Ñ–∏–≥ ‚Üí –∏—Å–ø—Ä–∞–≤—å ‚Üí –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–π.",
            "MCP –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –Ω–æ –ø–æ —Ç–≤–æ–µ–º—É –≤–æ–ø—Ä–æ—Å—É –º–æ–≥—É —Å–∫–∞–∑–∞—Ç—å –±–∞–∑–æ–≤–æ. –î–ª—è –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã –Ω—É–∂–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞."
        };

        var random = new Random();
        var response = responses[random.Next(responses.Length)];

        _logger.LogInformation("Generated Ivan-style MCP fallback response");
        return response;
    }
}
